{
    "exercises": [
        {
            "title": "Bilan Hashing",
            "description": "Etant donné une fonction de hachage :math:`h(\\left[v_0 \\cdots v_n \\right]) = \\sum_{i=0}^{n} v_i R^{(n-i-1)} \\% M` dans laquelle :math:`\\left[v_0 \\cdots v_n \\right]` dénote un vecteur de bit et :math:`R` et :math:`M` sont des facteurs constants.\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "Bilan M1 - Circular LinkedList",
            "description": "Context\n==================================================\n\n`Description <bilan_m1/bilan_m1.pdf>`_ of the implementation exercise and interesting questions to improve your skills.\n\nFill-in the body of each method (TODO) below in the corresponding textfield.\ngrade: 50% for the correctness of your implementation (correct or not), 50% for the efficiency (efficient or not).\n\n\n\n.. code-block:: java\n\n   public class NodeQueue<E> implements Queue<E> {\n\n       // Variables d’instance\n\n       private Node<E> marker;\n       private int size;\n\n\n       @Override\n       public int size() {\n           // TODO\n           return 0;\n       }\n\n       @Override\n       public boolean isEmpty() {\n           // TODO\n           return true;\n       }\n\n       @Override\n       public E front() throws QueueEmptyException {\n           // TODO\n           return null;\n       }\n\n       @Override\n       public void enqueue(E element) {\n           // TODO\n\n       }\n\n       @Override\n       public E dequeue() throws QueueEmptyException {\n           // TODO\n           return null;\n       }\n   }\n\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M3 - Global Warming",
            "description": "Context\n==================================================\n\nAssume the following 5x5 matrix:\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nrepresented in the array here under:\n\n.. image:: bilan_m2_global_warming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\nEach entry of the matrix represents an altitude.\nThe objective is to implement a class `GlobalWarmingImpl` that the method described in `GlobalWarming` given next.\n\nGiven a global water level, all the positions of the matrix with a value <= the water level are flooded (under the water) and thus unsafe. So assuming the water level is 3, all the safe points are green.\n\nThe methods you must implement is\n\n* the computations of the number of safe-points given a specified water level\n\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n\n       final int[][] altitude;\n\n       /**\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        */\n       public GlobalWarming(int[][] altitude) {\n           this.altitude = altitude;\n       }\n\n       /**\n        *\n        * @param waterLevel\n        * @return the number of entries in altitude matrix that would be above\n        *         the specified waterLevel.\n        *         Warning: this is not the waterLevel given in the constructor/\n        */\n       public abstract int nbSafePoints(int waterLevel);\n\n   }\n\n\n\nPreliminary exercises\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab);\n\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M4 - Incremental Hash",
            "description": "La fonction de Hash calculée sur le sous tableau t[from,...,from+M-1] est calculée comme suit:\n\n:math:`hash([from,...,from+M-1])= \\left( \\sum_{i=0}^{M-1} t[from+i] \\cdot R^{(M-1-i)}\\right)\\%Q`\n\nLe code pour calculer cette fonction de hash vous est donné.\nNous vous demandons de calculer\n:math:`hash([from,...,from+M-1])` au départ de\n:math:`hash([from-1,...,from+M-2])` en O(1).\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M5 - Huffman",
            "description": "Vous devez calculer un arbre de Huffman au départ de la fréquence donnée pour chacune des R lettres (characters).\n\nPour rappel, dans un arbre de Huffman nous avons que *la somme de la fréquence associée à chaque feuille multipliée par la profondeur de celle-ci est minimale*.\n\nPar exemple, étant donné les fréquences suivantes:\n\n.. image:: bilan_m5_huffman/huffmanin.png\n    :width: 500px\n    :align: center\n    :alt: Input frequencies\n\nun arbre de Huffman pourrait être:\n\n.. image:: bilan_m5_huffman/huffmanout.png\n    :width: 500px\n    :align: center\n    :alt: Huffman tree",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M6 - Connected Components",
            "description": "L'API de la classe `Graph <bilan_m6_cc/javadoc.zip>`_.\n\n\nL'API de `Java <https://docs.oracle.com/javase/8/docs/api/>`_.\n\n.. code-block:: java\n\n    public class ConnectedComponents {\n      /**\n       * @return the number of connected components in g\n       */\n      public static int numberOfConnectedComponents(Graph g) {\n        // TODO\n        return 0;\n      }\n    }",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Mid-Term Quizz: Closest Pair",
            "description": "Implémentez un algorithme qui reçoit en entrée un tableau d'entiers et qui trouve deux valeurs issues de tableau dont la somme se rapproche le plus d'une valeur entière donnée :math:`x`. Soiet :math:`(a,b)` les deux valeurs trouvées, celles-ci doivent donc minimiser :math:`|x-(a+b)|`.\nLes deux valeurs peuvent correspondre à la même entrée du tableau.\n\nPar exemple pour le tableau suivant\n\n.. code-block:: java\n\n    int [] input = new int [] {5,10,1,75,150,151,155,18,75,50,30};\n\n\n* x=20, il faut retourner [10,10].\n* x=153, il faut retrouner [1,151]\n* x=13, il faut retrouner [1,10]\n* x=140 il faut retourner [75,75]\n* x=170 il faut retourner [18,151]\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/closestpair/project.zip>`_.\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "EXAM0119 - LinearProbing",
            "description": "Dans ce exercice il vous est demandé d'implémenter les fonctions ``resize``, ``put`` et ``get`` d'une table de symbole basé sur le hashage par Linear Probing.\n\nPour cela la classe suivant vous a été donné. Vous devez completer les *TODO*.\n\n\n\n.. code-block:: java\n\n    import java.util.Arrays;\n\n    /**\n    * Symbol-table implementation with linear-probing hash table.\n    */\n    public class LinearProbingHashST<Key, Value> {\n\n    private int n;           // number of key-value pairs in the symbol table\n    private int m;           // size of linear probing table\n    private Key[] keys;      // the keys\n    private Value[] vals;    // the values\n\n\n    /**\n     * Initializes an empty symbol table.\n     */\n    public LinearProbingHashST() {this(16);}\n\n     /**\n     * Initializes an empty symbol table with the specified initial capacity.\n     */\n    public LinearProbingHashST(int capacity) {\n        m = capacity;\n        n = 0;\n        keys = (Key[])   new Object[m];\n        vals = (Value[]) new Object[m];\n    }\n\n    public int size() {return n;}\n    public boolean isEmpty() {return size() == 0;}\n\n    // hash function for keys - returns value between 0 and M-1\n    private int hash(Key key) {\n        return (key.hashCode() & 0x7fffffff) % m;\n    }\n\n    /**\n    * resizes the hash table to the given capacity by re-hashing all of the keys\n    */\n    private void resize(int capacity) {\n        //TODO STUDENT\n    }\n\n    /**\n    * Inserts the specified key-value pair into the symbol table, overwriting the old\n    * value with the new value.\n    */\n    public void put(Key key, Value val) {\n        //TODO STUDENT\n    }\n\n    /**\n    * Returns the value associated with the specified key.\n    */\n    public Value get(Key key) {\n        //TODO STUDENT\n    }\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/EXAM0119LinearProbing/LSINF1121_EXAM0119_LinearProbing.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M6 - Global Warming",
            "description": "Context\n==================================================\n\nAssume the following 5x5 matrix:\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nrepresented in the array here under:\n\n.. image:: globalwarming_graph/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\nEach entry of the matrix represents an altitude.\nThe objective is to implement a class `GlobalWarmingImpl` that implements all the methods described in `GlobalWarming` given next.\n\nA global water level specified in the constructor models the fact that all the positions of the matrix with a value <= the water level are flooded (under the water) and thus unsafe.\nIn the above example, the water level is 3, all the safe points are green.\n\nThe method you must implement is the computation of the shortest path between two positions on a same island\n\nwe assume that points are **only connected vertially or horizontally**.\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n       /**\n        * A class to represent the coordinates on the altitude matrix\n        */\n       public static class Point {\n\n           final int x, y;\n\n           Point(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n\n           @Override\n           public boolean equals(Object obj) {\n               Point p = (Point) obj;\n               return p.x == x && p.y == y;\n           }\n       }\n\n       final int[][] altitude;\n       final int waterLevel;\n\n\n       /**\n        * In the following, we assume that the points are connected to\n        * horizontal or vertical neighbors but not to the diagonal ones\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        * @param waterLevel is the water level, every entry <= waterLevel is flooded\n        */\n       public GlobalWarming(int[][] altitude, int waterLevel) {\n           this.altitude = altitude;\n           this.waterLevel = waterLevel;\n       }\n\n\n       /**\n        *\n        * @param p1 a safe point with valid coordinates on altitude matrix\n        * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\n        * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\n        *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\n        */\n       public abstract List<Point> shortestPath(Point p1, Point p2);\n\n   }\n\n\n\nPreliminary exercises\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab,3);\n\n.. image:: globalwarming_graph/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M5 - Global Warming",
            "description": "Context\n==================================================\n\nAssume the following 5x5 matrix:\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nrepresented in the array here under:\n\n.. image:: globalwarming_unionfind/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\nEach entry of the matrix represents an altitude.\nThe objective is to implement a class `GlobalWarmingImpl` that implements all the methods described in `GlobalWarming` given next.\n\nA global water level specified in the constructor models the fact that all the positions of the matrix with a value <= the water level are flooded (under the water) and thus unsafe.\nIn the above example, the water level is 3, all the safe points are green.\n\nThe methods you must implement are\n\n* the number of islands\n* a test to verify if two positions are on the same island\n\nwe assume that points are **only connected vertially or horizontally**.\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n       /**\n        * A class to represent the coordinates on the altitude matrix\n        */\n       public static class Point {\n\n           final int x, y;\n\n           Point(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n\n           @Override\n           public boolean equals(Object obj) {\n               Point p = (Point) obj;\n               return p.x == x && p.y == y;\n           }\n       }\n\n       final int[][] altitude;\n       final int waterLevel;\n\n\n       /**\n        * In the following, we assume that the points are connected to\n        * horizontal or vertical neighbors but not to the diagonal ones\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        * @param waterLevel is the water level, every entry <= waterLevel is flooded\n        */\n       public GlobalWarming(int[][] altitude, int waterLevel) {\n           this.altitude = altitude;\n           this.waterLevel = waterLevel;\n       }\n\n\n       /**\n        * An island is a connected components of safe points wrt to waterLevel\n        * @return the number of islands\n        */\n       public abstract int nbIslands();\n\n       /**\n        *\n        * @param p1 a point with valid coordinates on altitude matrix\n        * @param p2 a point with valid coordinates on altitude matrix\n        * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\n        *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\n        */\n       public abstract boolean onSameIsland(Point p1, Point p2);\n\n\n   }\n\n\nPreliminary exercises\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab,3);\n\n.. image:: globalwarming_unionfind/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 1 - Linked List Stack (Implem)",
            "description": "Il vous est demandé d'implémenter l'interface suivante, représentant une pile, en utilisant une liste simplement chainée. Vous devriez avoir au moins un constructeur sans argument, créant une pile vide.\n\nNote: utiliser *java.util.Stack<E>* est interdit!\n\n.. code-block:: java\n\n    import java.util.EmptyStackException;\n\n    public interface Stack<E> {\n\n        public boolean empty();\n\n        public E peek() throws EmptyStackException;\n\n        public E pop() throws EmptyStackException;\n\n        public void push(E item);\n\n    }\n\n\n\n.. code-block:: java\n\n    import java.util.EmptyStackException;\n\n    public class MyStack<E> implements Stack<E> {\n\n        private Node<E> top;        // the node on the top of the stack\n        private int size;        // size of the stack\n\n        // helper linked list class\n        private class Node<E> {\n            private E item;\n            private Node<E> next;\n\n            public Node(E element, Node<E> next) {\n                this.item = element;\n                this.next = next;\n            }\n        }\n\n        /**\n        * Tests if this stack is empty\n        */\n        @Override\n        public boolean empty() {\n            // TODO STUDENT: Implement empty method\n        }\n\n        /**\n        * Looks at the object at the top of this stack\n        * without removing it from the stack\n        */\n        @Override\n        public E peek() throws EmptyStackException {\n            // TODO STUDENT: Implement peek method\n        }\n\n        /**\n        * Removes the object at the top of this stack\n        * and returns that object as the value of this function\n        */\n        @Override\n        public E pop() throws EmptyStackException {\n            // TODO STUDENT: Implement pop method\n        }\n\n        /**\n        * Pushes an item onto the top of this stack\n        * @param item the item to append\n        */\n        @Override\n        public void push(E item) {\n            // TODO STUDENT: Implement push method\n\n        }\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/m1stack/LSINF1121_PART1_Stack.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 1 - Write Unit tests Stack (Implem)",
            "description": "Rappelez-vous de l'interface Stack :\n\n.. code-block:: java\n\n    import java.util.EmptyStackException;\n\n    public interface Stack<E> {\n\n        public boolean empty();\n\n        public E peek() throws EmptyStackException;\n\n        public E pop() throws EmptyStackException;\n\n        public void push(E item);\n\n    }\n\nIl vous est demandé d'écrire des tests unitaire (en utilisant JUnit) afin de vérifier si une implémentation particulière de cette interface est correcte.\n\nVoici un modèle simple que vous pouvez utiliser pour écrire vos tests (vous pouvez utiliser d'autres types que des String, bien sûr !) :\n\n.. code-block:: java\n\n    import org.junit.Test;\n    import static org.junit.Assert.assertEquals;\n\n    public class StackTests {\n\n        @Test\n        public void firstTest() {\n            Stack<Integer> stack = new MyStack<Integer>();\n            stack.push(1);\n            assertEquals(new Integer(1), stack.pop());\n        }\n\n        @Test\n        public void secondTest() {\n            // ... TODO ...\n        }\n\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/m1stacktests/LSINF1121_PART1_Stack.zip>`_.\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M2 - QCM",
            "description": "",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "Bilan M2 - Median",
            "description": "Nous vous donnons l'API d'une classe Vector permettant d'accéder, modifier et interchanger deux élements en temps constant.\nVotre tâche est d'implémenter une méthode permettant de calculer la médiane d'un Vecteur.\n\n.. code-block:: java\n\n    public interface Vector {\n        // taille du vecteur\n        public int size();\n        // mets la valeur v à l'indice i du vecteur\n        public void set(int i, int v);\n        // renvoie la valeur à l'indice i du vecteur\n        public int get(int i);\n        // échange les valeurs aux positions i et j\n        public void swap(int i, int j);\n\n    }\n\n`Un projet Eclipse contenant des tests basiques vous est fourni en cliquant sur ce lien. <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/median/project.zip>`_",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 1 -  Circular linkedlist (Implem)",
            "description": "On s’intéresse à l'implémentation d'une ``liste simplement chaînée circulaire``, c’est-à-dire une liste pour laquelle la dernière position de la liste fait référence, comme position suivante, à la première position de la liste.\n\n.. image:: p1circularlinkedlist/CircularLinkedList.png\n\nL’ajout d’un nouvel élément dans la file (méthode ``enqueue``) se fait en fin de liste et le retrait (méthode ``remove``) se fait a un `index` particulier de la liste. Une (seule) référence sur la fin de la liste (``last``) est nécessaire pour effectuer toutes les opérations sur cette file.\n\nIl vous est donc demander d'implémenter cette liste simplement chaînée circulaire à partir de la classe ``CircularLinkedList.java`` où vous devez completer (*TODO STUDENT*) les méthodes d'ajout (``enqueue``) et de retrait (``remove``) ainsi qu'un itérateur (``ListIterator``) qui permet de parcourir la liste en FIFO.\n*Attention:* un itérateur ne peut être modifié au cours de son utilisation.\n\n.. code-block:: java\n\n   package student;\n\n   import java.util.ConcurrentModificationException;\n   import java.util.Iterator;\n   import java.util.NoSuchElementException;\n\n   public class CircularLinkedList<Item> implements Iterable<Item> {\n    private long nOp = 0; // count the number of operations\n    private int n;          // size of the stack\n    private Node  last;   // trailer of the list\n\n    // helper linked list class\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    public CircularLinkedList() {\n        last = null;\n        n = 0;\n    }\n\n    public boolean isEmpty() { return n == 0; }\n\n    public int size() { return n; }\n\n    private long nOp() { return nOp; }\n\n    /**\n     * Append an item at the end of the list\n     * @param item the item to append\n     */\n    public void enqueue(Item item) {\n        // TODO STUDENT: Implement add method\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     */\n    public Item remove(int index) {\n        // TODO STUDENT: Implement remove method\n    }\n\n    /**\n     * Returns an iterator that iterates through the items in FIFO order.\n     * @return an iterator that iterates through the items in FIFO order.\n     */\n    public Iterator<Item> iterator() {\n        return new ListIterator();\n    }\n\n    /**\n     * Implementation of an iterator that iterates through the items in FIFO order.\n     *\n     */\n    private class ListIterator implements Iterator<Item> {\n        // TODO STUDDENT: Implement the ListIterator\n    }\n\n   }\n\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/p1circularlinkedlist/LSINF1121CircularLinkedList.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 1 -  Circular linkedlist (Implem)",
            "description": "On s’intéresse à l'implémentation d'une ``liste simplement chaînée circulaire``, c’est-à-dire une liste pour laquelle la dernière position de la liste fait référence, comme position suivante, à la première position de la liste.\n\n.. figure:: Part1CircularLinkedList/CircularLinkedList.png\n   :scale: 100 %\n   :alt: alternate text\n   :align: center\n   :figclass: align-center\n\nL’ajout d’un nouvel élément dans la file (méthode ``enqueue``) se fait en fin de liste et le retrait (méthode ``remove``) se fait a un `index` particulier de la liste. Une (seule) référence sur la fin de la liste (``last``) est nécessaire pour effectuer toutes les opérations sur cette file.\n\nIl vous est donc demander d'implémenter cette liste simplement chaînée circulaire à partir de la classe ``CircularLinkedList.java`` où vous devez completer (*TODO STUDENT*):\n\n- la méthode d'ajout (``enqueue``);\n\n- la méthode de retrait (``remove``) [L'exception ``IndexOutOfBoundsException`` est lancée quand la valeur de l'index n'est pas comprise en 0 et size()-1];\n\n- l'itérateur (``ListIterator``) qui permet de parcourir la liste en FIFO.\n\n*Attention:* L'itérateur devra lancer des exceptions dans les cas suivants:\n\n- étant donnée que le ``remove`` est optionnel dans l'`API <https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html>`_ , l'iterateur devra juste lancer un ``UnsupportedOperationException`` en cas d'appel du ``remove``;\n\n- étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en train d'itérer,  l'iterateur devra lancer un ``ConcurrentModificationException`` dans ce cas dans le ``next`` et le ``hasNest``;\n\n- si le ``next`` est appelé alors qu'il n'y a plus de prochain élément,  l'iterateur devra lancer un ``NoSuchElementException``.\n\n.. code-block:: java\n\n   import java.util.ConcurrentModificationException;\n   import java.util.Iterator;\n   import java.util.NoSuchElementException;\n\n   public class CircularLinkedList<Item> implements Iterable<Item> {\n    private long nOp = 0; // count the number of operations\n    private int n;          // size of the stack\n    private Node  last;   // trailer of the list\n\n    // helper linked list class\n    private class Node {\n        private Item item;\n        private Node next;\n    }\n\n    public CircularLinkedList() {\n        last = null;\n        n = 0;\n    }\n\n    public boolean isEmpty() { return n == 0; }\n\n    public int size() { return n; }\n\n    private long nOp() { return nOp; }\n\n    /**\n     * Append an item at the end of the list\n     * @param item the item to append\n     */\n    public void enqueue(Item item) {\n        // TODO STUDENT: Implement add method\n    }\n\n    /**\n     * Removes the element at the specified position in this list.\n     * Shifts any subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     */\n    public Item remove(int index) {\n        // TODO STUDENT: Implement remove method\n    }\n\n    /**\n     * Returns an iterator that iterates through the items in FIFO order.\n     * @return an iterator that iterates through the items in FIFO order.\n     */\n    public Iterator<Item> iterator() {\n        return new ListIterator();\n    }\n\n    /**\n     * Implementation of an iterator that iterates through the items in FIFO order.\n     *\n     */\n    private class ListIterator implements Iterator<Item> {\n        // TODO STUDENT: Implement the ListIterator\n    }\n\n   }\n\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part1CircularLinkedList/LSINF1121_PART1_CircularLinkedList.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 2 - Global Warming (implem)",
            "description": "Context\n==================================================\n\nSupposons la matrice 5x5 suivante :\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nreprésentée dans le tableau ci-dessous :\n\n.. image:: Part2GlobalWarming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\n\nChaque entrée de la matrice représente une altitude.\nL'objectif est d'implémenter une classe ``GlobalWarmingImpl`` qui étend la méthode `GlobalWarming` décrite ci-dessous.\n\nCompte tenu d'un niveau d'eau global, toutes les positions de la matrice ayant une valeur *<=* au niveau d'eau sont inondées et donc peu sûres. Donc, en supposant que le niveau d'eau est de *3*, tous les points sûrs sont en vert (dans la représentation ci-dessus).\n\nLa méthode que vous devez implémentez est ``nbSafePoints``\n\n* le calcul du nombre de points de sécurité pour un niveau d'eau donné\n\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n\n       final int[][] altitude;\n\n       /**\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        */\n       public GlobalWarming(int[][] altitude) {\n           this.altitude = altitude;\n       }\n\n       /**\n        *\n        * @param waterLevel\n        * @return the number of entries in altitude matrix that would be above\n        *         the specified waterLevel.\n        *         Warning: this is not the waterLevel given in the constructor/\n        */\n       public abstract int nbSafePoints(int waterLevel);\n\n   }\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part2GlobalWarming/LSINF1121_PART2_GlobalWarming.zip>`_.\n\nExercices préliminaires\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab);\n\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 2 - Median (implem)",
            "description": "Nous vous donnons l'API d'une classe Vector permettant d'accéder, modifier et interchanger deux élements en temps constant.\nVotre tâche est d'implémenter une méthode permettant de calculer la médiane d'un Vecteur.\n\n.. code-block:: java\n\n    public interface Vector {\n        // taille du vecteur\n        public int size();\n        // mets la valeur v à l'indice i du vecteur\n        public void set(int i, int v);\n        // renvoie la valeur à l'indice i du vecteur\n        public int get(int i);\n        // échange les valeurs aux positions i et j\n        public void swap(int i, int j);\n\n    }\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part2Median/LSINF1121_PART2_Median.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 2 - Merge Sort (implem)",
            "description": "Considérons l'algorithme de tri (descendant) ``Merge Sort``.\n\n.. code-block:: java\n\n    public class MergeSort {\n        /**\n         * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\n         * Post-conditions: a[lo..hi] is sorted\n         */\n        private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n            for (int k = lo; k <= hi; k++) {\n                aux[k] = a[k];\n            }\n\n            int i = lo;\n            int j = mid + 1;\n            for (int k = lo; k <= hi; k++) {\n                if (i > mid) {\n                    a[k] = aux[j++];\n                } else if (j > hi) {\n                    a[k] = aux[i++];\n                } else if (aux[j].compareTo(aux[i]) < 0) {\n                    a[k] = aux[j++];\n                } else {\n                    a[k] = aux[i++];\n                }\n            }\n        }\n\n        // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\n        private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n            // TODO\n        }\n\n        /**\n         * Rearranges the array in ascending order, using the natural order\n         */\n        public static void sort(Comparable[] a) {\n            // TODO\n        }\n    }\n\n**Note:** Les questions suivantes vous demanderont d'implémenter la fonction left out. Vous n'avez pas besoin de mettre les accolades (``{ }``) entourant le corps de la fonction dans votre réponse.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part2MergeSort/LSINF1121_PART2_MergeSort.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 2 - QCM",
            "description": "",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "PART 2 - Union Intervals (implem)",
            "description": "Etant donné un tableau d'intervalles (fermés), Il vous est demandé d'implémenter l'opération ``union``. Cette opération retournera le tableau minimal d'intervalles triés couvrant exactement l'union des points couverts par les intervalles d'entrée.\n\nPar exemple, l'union des intervalles *[7,9],[5,8],[2,4]* est *[2,4],[5,9]*.\n\nLa classe ``Interval`` permetant de stocker les intervalles vous est fourni et se présente comme suit (vous pouvez l'utiliser directement dans votre code):\n\n\n.. code-block:: java\n\n    public class Interval implements Comparable<Interval> {\n\n        final int min, max;\n        public Interval(int min, int max) {\n            assert(min <= max);\n            this.min = min;\n            this.max = max;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return ((Interval) obj).min == min && ((Interval) obj).max == max;\n        }\n\n        @Override\n        public String toString() {\n            return \"[\"+min+\",\"+max+\"]\";\n        }\n\n        @Override\n        public int compareTo(Interval o) {\n            if (min < o.min) return -1;\n            else if (min == o.min) return max - o.max;\n            else return 1;\n        }\n    }\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part2UnionIntervals/LSINF1121_PART2_UnionIntervals.zip>`_.\n\nNous vous conseillons de le télécharger d'implémenter/tester avant de soumettre ce qui vous est demandé.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 3 - Binary Search Tree (implem)",
            "description": "Etant donné un arbre de recherche binaire, dont les noeuds implémentent l'interface Node:\n\n.. code-block:: java\n\n    interface Node {\n        /**\n          * @return the value contained in this node\n          */\n        int getValue();\n\n        /**\n         * @return the node on the left (whose value is < than the current value)\n         * if it exists, null if not\n         */\n        Node getLeft();\n\n        /**\n          * @return the node on the right (whose value is > than the current value)\n          * if it exists, null if not\n          */\n        Node getRight();\n    }\n\nL'on vous demande de fournir le **corps** de la fonction *ceil*, qui trouve dans l'arbre le plus petit élément plus grand ou égal à `value` (donc soit l'élément lui-même soit l'élément situé directement après par ordre de grandeur). Si un tel élément n'existe pas, elle doit retourner `null`.\n\nPar exemple si on a ce BST,\n\n.. figure:: PART3Bst/bst.png\n   :scale: 70 %\n   :alt: alternate text\n   :align: center\n   :figclass: align-center\n\n\n- ceil(11) nous renverra 11,\n- ceil(4) nous renverra 8,\n- et ceil(21) nous renverra null.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/PART3Bst/LSINF1121_PART3_BinarySearchTree.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 3 - Binary Search Tree Iterator (implem)",
            "description": "On s’intéresse à l'implémentation d'un itérateur (``BSTIterator``) qui permet de traverser un ``Binary Search Tree`` dans l'ordre croissant (*In-order transversal*).\n\nPar exemple si on a ce BST,\n\n.. figure:: PART3OrderedBstIterator/bst.png\n   :scale: 70 %\n   :alt: alternate text\n   :align: center\n   :figclass: align-center\n\non veut le parcourir comme suit *[3,8,9,11,12,14,15,18,20]*\n\n*Attention:* L'itérateur devra lancer des exceptions dans les cas suivants:\n\n- étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en train d'itérer,  l'iterateur devra lancer un ``ConcurrentModificationException`` dans ce cas dans le ``next`` et le ``hasNest``;\n\n- si le ``next`` est appelé alors qu'il n'y a plus de prochain élément,  l'iterateur devra lancer un ``NoSuchElementException``.\n\n.. code-block:: java\n\n   import java.util.ConcurrentModificationException;\n   import java.util.Iterator;\n   import java.util.NoSuchElementException;\n   import java.util.Stack;\n\n      public class BST<Key extends Comparable<Key>, Value> implements Iterable<Key> {\n       private Node root;             // root of BST\n\n       private class Node {\n           private final Key key;       // sorted by key\n           private Value val;           // associated data\n           private Node left, right;    // left and right subtrees\n           private int size;            // number of nodes in subtree\n\n           public Node(Key key, Value val, int size) {\n               this.key = key;\n               this.val = val;\n               this.size = size;\n           }\n\n           public int getSize() {\n               return size;\n           }\n       }\n\n       /**\n        * Initializes an empty symbol table.\n        */\n       public BST() {}\n\n       /**\n        * Returns true if this symbol table is empty.\n        * @return {@code true} if this symbol table is empty; {@code false} otherwise\n        */\n       public boolean isEmpty() {\n           return size() == 0;\n       }\n\n       /**\n        * Returns the number of key-value pairs in this symbol table.\n        * @return the number of key-value pairs in this symbol table\n        */\n       public int size() {\n           return size(root);\n       }\n\n       // return number of key-value pairs in BST rooted at x\n       private int size(Node x) {\n           if (x == null) return 0;\n           else return x.size;\n       }\n\n       public void inOrder(){\n           inOrder(root);\n       }\n       private void inOrder(Node x) {\n           if (x == null) return;\n\n           inOrder(x.left);\n           System.out.println(x.key+\"=>\"+x.val);\n           inOrder(x.right);\n       }\n\n       /**\n        * Returns the value associated with the given key.\n        *\n        * @param  key the key\n        * @return the value associated with the given key if the key is in the symbol table\n        *         and {@code null} if the key is not in the symbol table\n        */\n       public Value get(Key key) {\n           return get(root, key);\n       }\n\n       private Value get(Node x, Key key) {\n           if (x == null) return null;\n           int cmp = key.compareTo(x.key);\n           if      (cmp < 0) return get(x.left, key);\n           else if (cmp > 0) return get(x.right, key);\n           else              return x.val;\n       }\n\n       /**\n        * Search for key, update value if key is found. Grow table if key is new.\n        *\n        * @param  key the key\n        * @param  val the value\n        */\n       public void put(Key key, Value val) {\n           root = put(root, key, val);\n       }\n       private Node put(Node x, Key key, Value val) {\n           if (x == null) return new Node(key, val, 1);\n           int cmp = key.compareTo(x.key);\n           if      (cmp < 0) x.left  = put(x.left,  key, val);\n           else if (cmp > 0) x.right = put(x.right, key, val);\n           else              x.val   = val;\n           x.size = 1 + size(x.left) + size(x.right);\n           return x;\n       }\n\n       /**\n        * Returns an iterator that iterates through the keys in Incresing order\n        * (In-Order transversal).\n        * @return an iterator that iterates through the items in FIFO order.\n        */\n       @Override\n       public Iterator<Key> iterator() {\n           return new BSTIterator();\n       }\n\n           /**\n     * Implementation of an iterator that iterates through the keys of BST in incresing order (In-order transversal).\n     *\n     */\n       private class BSTIterator implements Iterator<Key> {\n\n           // TODO STUDDENT: Implement the BSTIterator\n\n       }\n   }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/PART3OrderedBstIterator/LSINF1121_PART3_OrderedBstIterator.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 3 - QCM",
            "description": "",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "PART 3 - QCM Binary Trees",
            "description": "Consider this ordered binary tree:\n\n.. figure:: PART3QcmBt/bt.png\n   :scale: 70 %\n   :alt: alternate text\n   :align: center\n   :figclass: align-center\n\nWe traverse this tree and we print the value of each node we  visit it.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "PART 3 - Red Black Tree",
            "description": "Prenons l'exemple d'un ``Red-Black Tree`` vide dans lequel on ajoute progressivement des chiffres.\n\nLes questions suivantes vous demanderont d'écrire une représentation du ``Red-Black Tree`` au fur et à mesure que nous y ajouterons des objets.\n\nÉcrivez la réponse comme si vous lisiez le ``Red-Black Tree`` de gauche à droite et de haut en bas (en ignorant les blancs possibles). Par exemple, si votre réponse est :\n\n.. figure:: PART3Rbt/rbt.png\n   :scale: 70 %\n   :alt: alternate text\n   :align: center\n   :figclass: align-center\n\nVous écririez:\n\n::\n\n    6 24 7 1 3 5 9\n\nRemarquez comment le nœud 2-3 composé de ``2``et ``4`` est écrit d'une manière fusionnée (``24``).",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 3 - Write Unit tests Red Black Tree",
            "description": "Il vous est demandé d'écrire des tests unitaire (en utilisant JUnit) afin de vérifier si une implémentation particulière d'un ``Red-Black Tree`` est correcte.\n\nVoici un modèle simple que vous pouvez utiliser pour écrire vos tests :\n\n\n .. code-block:: java\n\n    import org.junit.Test;\n    import static org.junit.Assert.assertEquals;\n\n    public class RedBlackTests {\n\n        @Test\n        public void firstTest() {\n            // ... TODO ...\n        }\n\n        @Test\n        public void secondTest() {\n            // ... TODO ...\n        }\n\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/PART3WriteUnittestsRedBlackTree/LSINF1121_PART3_UnitTestsRedBlackTree.zip>`_.\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 4 - Incremental Hash (implem)",
            "description": "La fonction de Hash calculée sur le sous tableau :math:`t[from,...,from+M-1]` est calculée comme suit:\n\n:math:`hash([from,...,from+M-1])= \\left( \\sum_{i=0}^{M-1} t[from+i] \\cdot R^{(M-1-i)}\\right)\\%Q`\n\nLe code pour calculer cette fonction de hash vous est donné.\nNous vous demandons de calculer\n:math:`hash([from,...,from+M-1])` au départ de\n:math:`hash([from-1,...,from+M-2])` en O(1).\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part4IncrementalHash/LSINF1121_PART4_IncrementalHash.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 4 - QCM Hashing",
            "description": "Etant donné une fonction de hachage:\n\n:math:`h(\\left[v_0 \\cdots v_{n-1} \\right]) = \\sum\\limits_{i=0}^{n-1} v_i R^{(n-i-1)} \\% M`\n\ndans laquelle :math:`\\left[v_0 \\cdots v_{n-1} \\right]` dénote un vecteur de bit et :math:`R` et :math:`M` sont des facteurs constants.\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "john Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "PART 4 - QCM Rabin Karp",
            "description": "A la page 777 du livre \"Algorithms\" 4th edition, on vous propose l'implémentation suivante de l'algorithme de Rabin Karp.\n\n.. code-block:: java\n\n    public class RabinKarp {\n      private String pat;      // the pattern  // needed only for Las Vegas\n      private long patHash;    // pattern hash value\n      private int m;           // pattern length\n      private long q;          // a large prime, small enough to avoid long overflow\n      private int R;           // radix\n      private long RM;         // R^(M-1) % Q\n\n      public RabinKarp(String pat) {\n          this.pat = pat;      // save pattern (needed only for Las Vegas)\n          R = 256;\n          m = pat.length();\n          q = longRandomPrime();\n\n          // precompute R^(m-1) % q for use in removing leading digit\n          RM = 1;\n          for (int i = 1; i <= m-1; i++)\n              RM = (R * RM) % q;\n          patHash = hash(pat, m);\n      }\n\n      // Compute hash for key[0..m-1].\n      private long hash(String key, int m) {\n          long h = 0;\n          for (int j = 0; j < m; j++)\n              h = (R * h + key.charAt(j)) % q;\n          return h;\n      }\n\n      // Monte Carlo\n      private boolean check(int i) {\n          return true;\n      }\n\n      // Returns the index of the first occurrrence of the pattern string in the text string.\n      public int search(String txt) {\n          int n = txt.length();\n          if (n < m) return n;\n          long txtHash = hash(txt, m);\n\n          // check for match at offset 0\n          if ((patHash == txtHash) && check(txt, 0))\n              return 0;\n\n          // check for hash match; if hash match, check for exact match\n          for (int i = m; i < n; i++) {\n              // Remove leading digit, add trailing digit, check for match.\n              txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\n              txtHash = (txtHash*R + txt.charAt(i)) % q;\n\n              // match\n              int offset = i - m + 1;\n              if ((patHash == txtHash) && check(txt, offset))\n                  return offset;\n          }\n\n          // no match\n          return n;\n      }\n\n\n      // a random 31-bit prime\n      private static long longRandomPrime() {\n          BigInteger prime = BigInteger.probablePrime(31, new Random());\n          return prime.longValue();\n      }\n\n    }\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "PART 4 - Rabin Karp of k patterns (implem)",
            "description": "On s'intéresse à l'algorithme de Rabin-Karp. On voudrait le modifier quelque peu pour déterminer si un mot parmi une liste (tous les mots sont de même longueur) est présent dans le texte.\n\nPour cela, vous devez modifier l'algorithme de Rabin-Karp qui se trouve ci-dessous (Page 777 du livre).\n\n\n\n\n\n\n\nPlus précisément, on vous demande de modifier cette classe de manière à avoir un constructeur de la forme:\n\n.. code-block:: java\n\n public RabinKarp(String[] pat)\n\n\nDe plus la fonction ``search`` doit retourner l'indice du début du premier mot (parmi le tableau ``pat``) trouvé dans le texte ou la taille du texte si aucun mot n'aparait dans le texte.\n\nExemple:\nSi txt = “Here find interresting exercise for Rabin Karp” et pat={“have”, “find”, “Karp”} la fonction ``search`` doit renvoyer 5 car le mot \"find\" présent dans le texte et dans la liste commence à l'indice 5.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part4RabinKarp/LSINF1121_PART4_RabinKarp.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 5 - Binary Heap Push (implem)",
            "description": "Dans cette tâche on vous propose d'implémenter la fonction d'insertion ``push()`` d'un heap binaire.\n\n    La fonction push agit sur un tableau, nommé ``contenu``, qui représente un arbre, selon la méthode vue au cours:\n    le noeud n°i de l'arbre a pour enfant les indices 2*i et 2*i+1.\n\nil faut noter que dans le livre à la page 318 a été proposée le ``MaxPQ`` mais ici nous vous proposons de plutot réfléchir aux changements à apporter à ce code pour implémenter un ``MinPQ`` notamment à la fonction d'insertion.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/PART5BinaryHeapPush/LSINF1121_PART5_BinaryHeapPush.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 5 - Global Warming (implem)",
            "description": "Context\n==================================================\n\nSupposons la matrice 5x5 suivante:\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nreprésentée dans le tableau ci-dessous :\n\n.. image:: Part5GlobalWarming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\nChaque entrée de la matrice représente une altitude.\nL'objectif est d'implémenter une classe `GlobalWarmingImpl` qui implémente toutes les méthodes décrites dans `GlobalWarming` données ci-dessous.\n\nUn niveau d'eau global spécifié dans le constructeur modélise le fait que toutes les positions de la matrice avec une valeur <= le niveau d'eau sont inondées (sous l'eau) et donc dangereuses.\nDans l'exemple ci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.\n\nLes méthodes que vous devez implémenter sont les suivantes\n\n* le nombre d'îles\n* un test pour vérifier si deux positions sont sur la même île\n\nnous supposons que les points sont **uniquement connectés verticalement ou horizontalement**.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part5GlobalWarming/LSINF1121_PART5_GlobalWarming.zip>`_.\n\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n       /**\n        * A class to represent the coordinates on the altitude matrix\n        */\n       public static class Point {\n\n           final int x, y;\n\n           Point(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n\n           @Override\n           public boolean equals(Object obj) {\n               Point p = (Point) obj;\n               return p.x == x && p.y == y;\n           }\n       }\n\n       final int[][] altitude;\n       final int waterLevel;\n\n\n       /**\n        * In the following, we assume that the points are connected to\n        * horizontal or vertical neighbors but not to the diagonal ones\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        * @param waterLevel is the water level, every entry <= waterLevel is flooded\n        */\n       public GlobalWarming(int[][] altitude, int waterLevel) {\n           this.altitude = altitude;\n           this.waterLevel = waterLevel;\n       }\n\n\n       /**\n        * An island is a connected components of safe points wrt to waterLevel\n        * @return the number of islands\n        */\n       public abstract int nbIslands();\n\n       /**\n        *\n        * @param p1 a point with valid coordinates on altitude matrix\n        * @param p2 a point with valid coordinates on altitude matrix\n        * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\n        *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\n        */\n       public abstract boolean onSameIsland(Point p1, Point p2);\n\n\n   }\n\n\nPreliminary exercises\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab,3);\n\n.. image:: Part5GlobalWarming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 5 - Heap",
            "description": "Considérons la structure de données ``Heap`` dans laquelle on ajoute progressivement des nombres.\n\nLes questions suivantes vous demanderont d'écrire une représentation du ``Heap`` au fur et à mesure que nous y ajoutons des objets. Vous devez écrire le ``Heap`` comme s'il était stocké dans un tableau. Par exemple, si votre réponse est :\n\n::\n\n        9\n       / \\\n      5   8\n     / \\\n    4   3\n\nVous devriez écrire:\n\n::\n\n    9 5 8 4 3",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 5 - Huffman (implem)",
            "description": "Vous devez calculer un arbre de Huffman au départ de la fréquence donnée pour chacune des R lettres (characters).\n\nPour rappel, dans un arbre de Huffman nous avons que *la somme de la fréquence associée à chaque feuille multipliée par la profondeur de celle-ci est minimale*.\n\nPar exemple, étant donné les fréquences suivantes:\n\n\n.. image:: Part5Huffman/huffmanin.png\n                :width: 500px\n                :align: center\n                :alt: Input frequencies\n\n\nun arbre de Huffman pourrait être:\n\n\n.. image:: Part5Huffman/huffmanout.png\n                :width: 500px\n                :align: center\n                :alt: Huffman tree\n\n\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part5Huffman/LSINF1121_PART5_Huffman.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 5 - Union find",
            "description": "Considérons un graphe composé de 10 nœuds disjoints (numérotés de 0 à 9). Nous utilisons une structure de données union-find pour représenter ce graphe. Dans un premier temps, chaque nœud est contenu dans une partition qui porte son nom. Ainsi, la représentation du graphique dans le tableau ``id[]`` est :\n\n::\n\n    0 1 2 3 4 5 6 7 8 9\n\nLes questions suivantes vous demanderont de donner la représentation du graphe après avoir utilisé l'algorithme **quick-find** pour ajouter une arête entre 2 noeuds. Vous devez donner cette représentation de la même manière qu'elle a été donnée ci-dessus.\n\n**Note:** Lorsque nous joignons ``p-q`` avec l'algorithme quick-find, la convention est de changer ``id[p]`` (et éventuellement d'autres entrées) mais pas ``id[q]``.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 6  - Breadth First Paths (implem)",
            "description": "Considérez cette classe, ``BreadthFirstShortestPaths``, qui calcule le chemin le plus court entre plusieurs sources de nœuds et n'importe quel nœud dans un graphe non dirigé en utilisant un parcours BFS.\n\n.. code-block:: java\n\n    // TODO\n\n    public class BreadthFirstShortestPaths {\n\n        private static final int INFINITY = Integer.MAX_VALUE;\n        private boolean[] marked; // marked[v] = is there an s-v path\n        private int[] distTo;     // distTo[v] = number of edges shortest s-v path\n\n        /**\n         * Computes the shortest path between any\n         * one of the sources and very other vertex\n         * @param G the graph\n         * @param sources the source vertices\n         */\n         public BreadthFirstShortestPaths(Graph G, Iterable<Integer> sources) {\n             marked = new boolean[G.V()];\n             distTo = new int[G.V()];\n             for (int v = 0;v < G.V();v++) {\n                 distTo[v] = INFINITY;\n             }\n             bfs(G, sources);\n         }\n\n         // Breadth-first search from multiple sources\n         private void bfs(Graph G, Iterable<Integer> sources) {\n             // TODO\n         }\n\n         /**\n          * Is there a path between (at least one of) the sources and vertex v?\n          * @param v the vertex\n          * @return true if there is a path, and false otherwise\n          */\n         public boolean hasPathTo(int v) {\n             // TODO\n         }\n\n         /**\n          * Returns the number of edges in a shortest path\n          * between one of the sources and vertex v?\n          * @param v the vertex\n          * @return the number of edges in a shortest path\n          */\n         public int distTo(int v) {\n             // TODO\n         }\n    }\n\nLa classe ``Graph`` est déjà implémentée et la voici :\n\n.. code-block:: java\n\n    public class Graph {\n        // @return the number of vertices\n        public int V() { }\n\n        // @return the number of edges\n        public int E() { }\n\n        // Add edge v-w to this graph\n        public void addEdge(int v, int w) { }\n\n        // @return the vertices adjacent to v\n        public Iterable<Integer> adj(int v) { }\n\n        // @return a string representation\n        public String toString() { }\n    }\n\n**Note:** Les questions suivantes vous demanderont d'implémenter tous les ``TODO`` de la classe ``BreadthFirstShortestPaths``. Vous n'avez pas besoin de mettre les accolades (``{ }``) entourant le corps de la fonction dans votre réponse.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6BreadthFirstPaths/LSINF1121_PART6_BreadthFirstShortestPaths.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 6 - Connected Components (implem)",
            "description": "Il vous ait demandé d'implémenter la classe des composants connexes ``ConnectedComponent`` étant donnée un graphe.\nLa classe `Graph <Part6ConnectedComponents/javadoc.zip>`_ disponible dans le code est celle de l'API de la classe `Java <https://docs.oracle.com/javase/8/docs/api/>`_.\n\n.. code-block:: java\n\n    public class ConnectedComponents {\n      /**\n       * @return the number of connected components in g\n       */\n      public static int numberOfConnectedComponents(Graph g) {\n        // TODO\n        return 0;\n      }\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6ConnectedComponents/LSINF1121_PART6_ConnectedComponents.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 6 - Depth First Paths (implem)",
            "description": "Considérez cette classe, ``DepthFirstPaths``, qui calcule les chemins vers n'importe quel noeud connecté à partir d'un noeud source ``s`` dans un graphe non dirigé en utilisant un parcours DFS.\n\n.. code-block:: java\n\n    // TODO\n\n    public class DepthFirstPaths {\n        private boolean[] marked; // marked[v] = is there an s-v path?\n        private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\n        private final int s;\n\n        /**\n         * Computes a path between s and every other vertex in graph G\n         * @param G the graph\n         * @param s the source vertex\n         */\n         public DepthFirstPaths(Graph G, int s) {\n             this.s = s;\n             edgeTo = new int[G.V()];\n             marked = new boolean[G.V()];\n             dfs(G, s);\n         }\n\n         // Depth first search from v\n         private void dfs(Graph G, int v) {\n             // TODO\n         }\n\n         /**\n          * Is there a path between the source s and vertex v?\n          * @param v the vertex\n          * @return true if there is a path, false otherwise\n          */\n         public boolean hasPathTo(int v) {\n             // TODO\n         }\n\n         /**\n          * Returns a path between the source vertex s and vertex v, or\n          * null if no such path\n          * @param v the vertex\n          * @return the sequence of vertices on a path between the source vertex\n          *         s and vertex v, as an Iterable\n          */\n         public Iterable<Integer> pathTo(int v) {\n             // TODO\n         }\n    }\n\nLa classe ``Graph`` est déjà implémentée. En voici la spécification :\n\n.. code-block:: java\n\n    public class Graph {\n        // @return the number of vertices\n        public int V() { }\n\n        // @return the number of edges\n        public int E() { }\n\n        // Add edge v-w to this graph\n        public void addEdge(int v, int w) { }\n\n        // @return the vertices adjacent to v\n        public Iterable<Integer> adj(int v) { }\n\n        // @return a string representation\n        public String toString() { }\n    }\n\n**Note:** Les questions suivantes vous demanderont d'implémenter tous les ``TODO`` de la classe ``DepthFirstPaths``. Vous n'avez pas besoin de mettre les accolades (``{ }``) entourant le corps de la fonction dans votre réponse.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6DepthFirstPaths/LSINF1121_PART6_DepthFirstPaths.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 6 - Digraph (implem)",
            "description": "Implémentez l'interface ``Digraph.java`` dans la classe ``DigraphImplem.java`` à l'aide d'une structure de donnée de type ``liste d'adjacence`` pour représenter les graphes dirigés.\n\n.. code-block:: java\n\n   package student;\n\n   public interface Digraph {\n\n       /**\n        * The number of vertices\n        */\n       public int V();\n\n       /**\n        * The number of edges\n        */\n       public int E();\n\n       /**\n        * Add the edge v->w\n        */\n       public void addEdge(int v, int w);\n\n       /**\n        * The nodes adjacent to edge v\n        */\n       public Iterable<Integer> adj(int v);\n\n       /**\n        * A copy of the digraph with all edges reversed\n        */\n       public Digraph reverse();\n\n   }\n\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6Digraph/LSINF1121_PART6_Digraph.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 6 - Word Transformation Shortest Path (implem)",
            "description": "On vous demande d'implémenter la classe ``WordTransformationSP`` qui permet de trouver le plus court chemin permettant de passer d'un string *A* à un autre string *B* (avec la certitude qu'il y a bien un chemin permettant de transformer *A* en *B*).\n\n\nPour cela on definit une opération ``rotation(x, y)`` qui inverse l’ordre des lettres entre la position x et y (non-inclus).\nPar exemple, avec A=``HAMBURGER``, si l'on fait ``rotation(A, 4, 8)``, cela nous donne ``HAMBEGRUR``. Vous pouvez donc constater que la sous-string ``URGE`` a été inversé en ``EGRU`` et le reste de la chaine est resté inchangé: ``HAMB`` + ``ECRU`` + ``R`` = ``HAMBEGRUR``.\n\nDisons qu’une ``rotation(x, y)`` a un cout de y-x. Par exemple passer de ``HAMBURGER`` à ``HAMBEGRUR`` coût *8-4 = 4*.\n\nLa question est de savoir quel est le coût minimum pour atteindre une string B à partir A?\n\nVous devez donc inmplémenter la méthode  une fonction ``public static int minimalCost(String A, String B)`` qui retourne le cout minimal pour atteindre le String B depuis A en utilisant l'opération rotation.\n\n.. code-block:: java\n\n    import java.util.*;\n\n    public  class WordTransformationSP {\n        /**\n         *\n         * Rotate the substring between start and end of a given string s\n         * eg. s = HAMBURGER, rotation(s,4,8) = HAMBEGRUR i.e. HAMB + EGRU + R\n         * @param s\n         * @param start\n         * @param end\n         * @return rotated string\n         */\n        public static String rotation(String s, int start, int end) {\n            return s.substring(0,start)+new StringBuilder(s.substring(start,end)).reverse().toString()+s.substring(end);\n        }\n\n        /**\n         * Compute the minimal cost from string \"from\" to string \"to\" representing the shortest path\n         * @param from\n         * @param to\n         * @return\n         */\n        public static int minimalCost(String from, String to) {\n            //TODO\n            return 0;\n        }\n    }\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6DijkstraForWordTransformation/LSINF1121_PART6_WordTransformation.zip>`_.\n\n**Note:** vous pouvez ajouter d'autres fonctions et des private classes si vous le désirez.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "PART 6 - Global Warming (implem)",
            "description": "Context\n==================================================\n\nSupposons la matrice 5x5 suivante:\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n\nreprésentée dans le tableau ci-dessous :\n\n.. image:: Part6GlobalWarming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\nChaque entrée de la matrice représente une altitude.\nL'objectif est d'implémenter une classe `GlobalWarmingImpl` qui implémente toutes les méthodes décrites dans `GlobalWarming` données ci-dessous.\n\nUn niveau d'eau global spécifié dans le constructeur modélise le fait que toutes les positions de la matrice avec une valeur <= le niveau d'eau sont inondées (sous l'eau) et donc dangereuses.\nDans l'exemple ci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.\n\nLa méthode que vous devez implémenter doit permettre de calculer le chemin le plus court entre deux positions sont sur la même île\n\nnous supposons que les points sont **uniquement connectés verticalement ou horizontalement**.\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6GlobalWarming/LSINF1121_PART6_GlobalWarming.zip>`_.\n\n.. code-block:: java\n\n\n   import java.util.List;\n\n   abstract class GlobalWarming {\n\n       /**\n        * A class to represent the coordinates on the altitude matrix\n        */\n       public static class Point {\n\n           final int x, y;\n\n           Point(int x, int y) {\n               this.x = x;\n               this.y = y;\n           }\n\n           @Override\n           public boolean equals(Object obj) {\n               Point p = (Point) obj;\n               return p.x == x && p.y == y;\n           }\n       }\n\n       final int[][] altitude;\n       final int waterLevel;\n\n\n       /**\n        * In the following, we assume that the points are connected to\n        * horizontal or vertical neighbors but not to the diagonal ones\n        * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\n        * @param waterLevel is the water level, every entry <= waterLevel is flooded\n        */\n       public GlobalWarming(int[][] altitude, int waterLevel) {\n           this.altitude = altitude;\n           this.waterLevel = waterLevel;\n       }\n\n\n       /**\n        *\n        * @param p1 a safe point with valid coordinates on altitude matrix\n        * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\n        * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\n        *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\n        */\n       public abstract List<Point> shortestPath(Point p1, Point p2);\n\n   }\n\n\n\nExercices Preliminaires\n==================================================\n\n\n.. code-block:: java\n\n    int [][] tab = new int[][] {{1,3,3,1,3},\n                              {4,2,2,4,5},\n                              {4,4,1,4,2},\n                              {1,4,2,3,6},\n                              {1,1,1,6,3}};\n    GlobalWarming gw = new MyGlobalWarming(tab,3);\n\n.. image:: Part6GlobalWarming/matrix.png\n                :width: 200px\n                :align: center\n                :alt: matrix example\n\n\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "PART 6 : Maze (implem)",
            "description": "Nous sommes intéressés par la résolution de labyrinthe (labyrinthe) représenté par une matrice d'entiers 0-1 de taille `nxm`. Cette matrice est un tableau à deux dimensions. Une entrée égale à '1' signifie qu'il y a un mur et que cette position n'est donc pas accessible, tandis que '0' signifie que la position est libre.\n\nNous vous demandons d'écrire un code Java pour découvrir le chemin le plus court entre deux coordonnées sur cette matrice de (x1, y1) à (x2, y2).\n\nLes déplacements ne peuvent être que verticaux ou horizontaux (pas en diagonale), un pas à la fois.\n\nLe résultat du chemin est un ``Iterable`` de coordonnées de l'origine à la destination. Ces coordonnées sont représentées par des entiers compris entre 0 et `n * m-1`, où un entier 'a' représente la position `x =a/m` et `y=a%m`.\n\nSi la position de début ou de fin est un mur ou s’il n’ya pas de chemin, il faut renvoyer un ``Iterable`` vide. Il en va de même s'il n'y a pas de chemin entre l'origine et la destination.\n\n.. code-block:: java\n\n    import java.util.LinkedList;\n\n    public class Maze {\n        public static Iterable<Integer> shortestPath(int [][] maze,  int x1, int y1, int x2, int y2) {\n            //TODO\n            return new LinkedList<>();\n        }\n\n        public static int ind(int x,int y, int lg) {return x*lg + y;}\n\n        public static int row(int pos, int mCols) { return pos / mCols; }\n\n        public static int col(int pos, int mCols) { return pos % mCols; }\n    }\n\n\n`Le projet IntelliJ est disponible ici </course/LSINF1121-2016/Part6Maze/LSINF1121_PART6_Maze.zip>`_.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Règles de participation aux cours",
            "description": "Ce qui est interdit\n-----------------------\n\nIl est interdit de partager son code avec un autre groupe et même avec son propre groupe pour les parties individuelles des missions.\n\nIl est interdit de publier son code de manière publique (``GitHub``, ``Bitbucket``, ``Dropbox`` ou ``Drive`` partagé, etc) pendant et après le quadrimestre.  Nous vous fournirons un repository ``Git`` pour vos travaux de groupes, qui sera seulement visible par les membres de votre groupe.\n\nIl est interdit de prendre le code de quelqu’un d’autre (même partiellement), y compris du code disponible sur le web. Seul le code fourni dans le livre de référence peut être utilisé.\n\nCe qui est autorisé\n------------------------------\n\nÉchanger et discuter des idées avec des collègues (y compris d’un autre groupe) est autorisé (oralement autour d’un tableau, sur un forum, etc). Mais il est interdit de demander et/ou fournir une réponse toute faite ou du code source.\n\nExemple de ce qui est interdit :\n\n- Tu as mis quoi à la réponse à la question 1 ?\n\nExemple de ce qui est autorisé :\n\n- J’hésite entre la méthode 1 et la méthode 2 pour réaliser l’objectif 1, je pense que la méthode 1 est meilleure pour la raison x, que penses-tu de cet argument ?\n\nPourquoi ?\n-------------\n\nCar le matériel pédagogique mis en place s’améliore chaque année et prend beaucoup de temps à développer. Le copyright de celui-ci appartient d’ailleurs à l’UCL et non aux étudiants.\n\nContourner les outils pédagogiques mis en place (par exemple en empruntant du code déjà écrit) ne vous rend pas service. C’est même le meilleur moyen d’échouer à l’examen qui visera précisément à évaluer les compétences acquises: programmation, réponses aux questions, etc.\n\nEn partageant du code ou des réponses (dans le meilleur des cas approximativement correctes...) vous inciteriez certains étudiants à ne pas réfléchir par eux-mêmes, voir pire, à apprendre des réponses potentiellement erronées.\n\nLa note de participation ne vise pas l’exactitude des productions (réponses, codes) mais l’attitude et la motivation de l’étudiant à s’améliorer et acquérir les compétences visées.\n\nRisque\n---------\n\nTout manquement à un de ces points sera sanctionné comme un acte de tricherie et sera dès lors reporté au président des jurys.  Pour rappel, en cas de tricherie, l'étudiant peut se voir attribuer un zéro pour le cours, voire se voir attribuer zéro pour l'ensemble des cours de la session.\n\nVos codes sont analysés par des outils de détection de plagiat. Un étudiant averti en vaut deux.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Kaczynski Frédéric",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M4 - Rabin Karp",
            "description": "A la page 777 du livre \"Algorithms\" 4th edition, on vous propose l'implémentation suivante de l'algorithme de Rabin Karp.\n\n.. code-block:: java\n\n    public class RabinKarp {\n      private String pat;      // the pattern  // needed only for Las Vegas\n      private long patHash;    // pattern hash value\n      private int m;           // pattern length\n      private long q;          // a large prime, small enough to avoid long overflow\n      private int R;           // radix\n      private long RM;         // R^(M-1) % Q\n\n      public RabinKarp(String pat) {\n          this.pat = pat;      // save pattern (needed only for Las Vegas)\n          R = 256;\n          m = pat.length();\n          q = longRandomPrime();\n\n          // precompute R^(m-1) % q for use in removing leading digit\n          RM = 1;\n          for (int i = 1; i <= m-1; i++)\n              RM = (R * RM) % q;\n          patHash = hash(pat, m);\n      }\n\n      // Compute hash for key[0..m-1].\n      private long hash(String key, int m) {\n          long h = 0;\n          for (int j = 0; j < m; j++)\n              h = (R * h + key.charAt(j)) % q;\n          return h;\n      }\n\n      // Monte Carlo\n      private boolean check(int i) {\n          return true;\n      }\n\n      // Returns the index of the first occurrrence of the pattern string in the text string.\n      public int search(String txt) {\n          int n = txt.length();\n          if (n < m) return n;\n          long txtHash = hash(txt, m);\n\n          // check for match at offset 0\n          if ((patHash == txtHash) && check(txt, 0))\n              return 0;\n\n          // check for hash match; if hash match, check for exact match\n          for (int i = m; i < n; i++) {\n              // Remove leading digit, add trailing digit, check for match.\n              txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\n              txtHash = (txtHash*R + txt.charAt(i)) % q;\n\n              // match\n              int offset = i - m + 1;\n              if ((patHash == txtHash) && check(txt, offset))\n                  return offset;\n          }\n\n          // no match\n          return n;\n      }\n\n\n      // a random 31-bit prime\n      private static long longRandomPrime() {\n          BigInteger prime = BigInteger.probablePrime(31, new Random());\n          return prime.longValue();\n      }\n\n    }\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "Bilan M6 - Breadth First Paths",
            "description": "Consider this class, ``BreadthFirstShortestPaths``, that computes the shortest path between multiple node sources and any node in an undirected graph.\n\n.. code-block:: java\n\n    // TODO\n\n    public class BreadthFirstShortestPaths {\n\n        private static final int INFINITY = Integer.MAX_VALUE;\n        private boolean[] marked; // marked[v] = is there an s-v path\n        private int[] distTo;     // distTo[v] = number of edges shortest s-v path\n\n        /**\n         * Computes the shortest path between any\n         * one of the sources and very other vertex\n         * @param G the graph\n         * @param sources the source vertices\n         */\n         public BreadthFirstShortestPaths(Graph G, Iterable<Integer> sources) {\n             marked = new boolean[G.V()];\n             distTo = new int[G.V()];\n             for (int v = 0;v < G.V();v++) {\n                 distTo[v] = INFINITY;\n             }\n             bfs(G, sources);\n         }\n\n         // Breadth-first search from multiple sources\n         private void bfs(Graph G, Iterable<Integer> sources) {\n             // TODO\n         }\n\n         /**\n          * Is there a path between (at least one of) the sources and vertex v?\n          * @param v the vertex\n          * @return true if there is a path, and false otherwise\n          */\n         public boolean hasPathTo(int v) {\n             // TODO\n         }\n\n         /**\n          * Returns the number of edges in a shortest path\n          * between one of the sources and vertex v?\n          * @param v the vertex\n          * @return the number of edges in a shortest path\n          */\n         public int distTo(int v) {\n             // TODO\n         }\n    }\n\nThe class ``Graph`` is already implemented. Here is its specification:\n\n.. code-block:: java\n\n    public class Graph {\n        // @return the number of vertices\n        public int V() { }\n\n        // @return the number of edges\n        public int E() { }\n\n        // Add edge v-w to this graph\n        public void addEdge(int v, int w) { }\n\n        // @return the vertices adjacent to v\n        public Iterable<Integer> adj(int v) { }\n\n        // @return a string representation\n        public String toString() { }\n    }\n\n**Note:** The following questions will ask you to implement the function left out. You don't need to put the brackets (``{ }``) surrounding the function body in your answer.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Pré-examen - Bloom Filters",
            "description": "Les filtres de Bloom\n--------------------\nUn filtre de Bloom, est une structure de donnée très compacte et efficace qui permet d'implémenter un test d'appartenance rapide (:code:`.contains()`) à un très grand *ensemble*. Cependant, contrairement au test d'appartenance à un ensemble tel qu'implémenté à l'aide d'une HashMap, le test d'appartenance implémenté via un filtre de bloom peut renvoyer un résultat erroné (faux positifs possibles mais pas de faux négatifs) dans certains cas et cela, avec une faible probabilité.\n\nL'efficacité de cette structure, et le fait qu'elle ne requière qu'une quantité très faible (et constante !) de mémoire quel que soit le nombre d'éléments contenus dans l'ensemble en ont fait une structure de choix pour un très grand nombre d'applications. A titre d'exemple, on mentionnera le fait que les filtres de Bloom sont utilisés par certains devices réseaux pour faire du *Deep Packet Inspection*, ou encore que les bases de données *Google Big Table*, *Apache Cassandra* ou encore *Postgresql* utilisent cette structure de donnée afin de tester si une donnée se trouve en cache ou non.\n\nEn effet la recherche de la donnée étant généralement coûteuse,\nun filtre de Bloom est utilisé pour éviter de faire une recherche\nsi la donnée n'est pas présente. Par contre, comme les erreurs de type faux-positifs sont possibles, le filtre de Bloom peut dire que la donnée s'y trouve alors que ça n'est pas vrai. Dans ce cas, il faudra effectuer la recherche pour vérifier et payer le coût de cette recherche (par exemple une recherche linéaire avec des accès\nsur le disque).\n\nConcrètement\n------------\nConcrètement, un filtre de bloom consiste en un vecteur :math:`V = v_1..v_n` de bit et d'un ensemble :math:`F = f_1..f_k` de fonctions de hachage\n\nPour ajouter un élément :math:`X` dans le set, on applique successivement chacune des fonctions :math:`f_i \\in F` de hachage. L'application de chacune de ces fonctions à l'élément :math:`X` renvoie un nombre :math:`h_i \\in \\left[0..n-1\\right]`. Pour marquer l'ajout de :math:`X` au filtre de bloom, on met à 1 simplement chacun des :math:`v_{h_i}` bits dans :math:`V`.\n\nDe façon similaire, pour tester l'appartenance d'un élément :math:`X` au set, on vérifie que le :math:`h_i` ème bit :math:`\\in V` correspondant à :math:`f_i(X)` est égal à 1. Le test d'appartenance ne renverra `true` que ssi, cette condition est vérifiée pour chacune des :math:`f_i \\in F`.\n\nExemples\n~~~~~~~~\nEn supposant qu'on ait un filtre de Bloom représenté par 1 byte et 3 fonctions de hachage telles que:\n\n.. code::\n\n    f1(\"Salut\") = 0\n    f2(\"Salut\") = 1\n    f3(\"Salut\") = 2\n\n    et\n\n    f1(\"1121\") = 0\n    f2(\"1121\") = 1\n    f3(\"1121\") = 4\n\nL'ajout de \"Salut\" au filtre 00000000 transforme celui-ci en 11100000. Si par la suite on veut tester que \"Salut\" est bien présent dans le filtre, on s'assure que les bits v1, v2 et v3 sont bien égaux à 1.\n\nEn continuant sur le même exemple, on voit que la chaine \"1121\" n'est pas présente dans la structure puisque le 4eme bit est égal à 0.\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "Bilan M6 - Depth First Paths",
            "description": "Consider this class, ``DepthFirstPaths``, that computes paths to any connected node from a source node ``s`` in an undirected graph.\n\n.. code-block:: java\n\n    // TODO\n\n    public class DepthFirstPaths {\n        private boolean[] marked; // marked[v] = is there an s-v path?\n        private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\n        private final int s;\n\n        /**\n         * Computes a path between s and every other vertex in graph G\n         * @param G the graph\n         * @param s the source vertex\n         */\n         public DepthFirstPaths(Graph G, int s) {\n             this.s = s;\n             edgeTo = new int[G.V()];\n             marked = new boolean[G.V()];\n             dfs(G, s);\n         }\n\n         // Depth first search from v\n         private void dfs(Graph G, int v) {\n             // TODO\n         }\n\n         /**\n          * Is there a path between the source s and vertex v?\n          * @param v the vertex\n          * @return true if there is a path, false otherwise\n          */\n         public boolean hasPathTo(int v) {\n             // TODO\n         }\n\n         /**\n          * Returns a path between the source vertex s and vertex v, or\n          * null if no such path\n          * @param v the vertex\n          * @return the sequence of vertices on a path between the source vertex\n          *         s and vertex v, as an Iterable\n          */\n         public Iterable<Integer> pathTo(int v) {\n             // TODO\n         }\n    }\n\nThe class ``Graph`` is already implemented. Here is its specification:\n\n.. code-block:: java\n\n    public class Graph {\n        // @return the number of vertices\n        public int V() { }\n\n        // @return the number of edges\n        public int E() { }\n\n        // Add edge v-w to this graph\n        public void addEdge(int v, int w) { }\n\n        // @return the vertices adjacent to v\n        public Iterable<Integer> adj(int v) { }\n\n        // @return a string representation\n        public String toString() { }\n    }\n\n**Note:** The following questions will ask you to implement the function left out. You don't need to put the brackets (``{ }``) surrounding the function body in your answer.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M5 - Heap",
            "description": "Consider the ``Heap`` data structure in which we progressively add numbers.\n\nThe following questions will ask you to write a representation of the ``Heap`` as we add objects in it. You must write the ``Heap`` as if it was stored in an array. For example, if your answer is:\n\n::\n\n        9\n       / \\\n      5   8\n     / \\\n    4   3\n\nYou would write:\n\n::\n\n    9 5 8 4 3",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M2 - Merge Sort",
            "description": "Consider the (top-down) sorting algorithm ``Merge Sort``\n\n.. code-block:: java\n\n    public class MergeSort {\n        /**\n         * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\n         * Post-conditions: a[lo..hi] is sorted\n         */\n        private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\n            for (int k = lo; k <= hi; k++) {\n                aux[k] = a[k];\n            }\n\n            int i = lo;\n            int j = mid + 1;\n            for (int k = lo; k <= hi; k++) {\n                if (i > mid) {\n                    a[k] = aux[j++];\n                } else if (j > hi) {\n                    a[k] = aux[i++];\n                } else if (aux[j].compareTo(aux[i]) < 0) {\n                    a[k] = aux[j++];\n                } else {\n                    a[k] = aux[i++];\n                }\n            }\n        }\n\n        // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\n        private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\n            // TODO\n        }\n\n        /**\n         * Rearranges the array in ascending order, using the natural order\n         */\n        public static void sort(Comparable[] a) {\n            // TODO\n        }\n    }\n\n**Note:** The following questions will ask you to implement the function left out. You don't need to put the brackets (``{ }``) surrounding the function body in your answer.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M3 - Red Black Tree",
            "description": "Consider an empty ``Red-Black Tree`` in which we progressively add numbers.\n\nThe following questions will ask you to write a representation of the ``Red-Black Tree`` as we add objects in it. Write it as if you were reading from left to right and from top to bottom (ignoring the possible blanks). For example, if your answer is:\n\n::\n\n          6\n        /   \\\n     (2 4)   7\n     / | \\    \\\n    1  3  5    9\n\nYou would write:\n\n::\n\n    6 24 7 1 3 5 9\n\nNotice how the 2-3 node composed of ``2`` and ``4`` is written in a merged way (``24``).",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M3 - QCM Binary Trees",
            "description": "Consider this ordered binary tree:\n\n::\n\n          4\n        /   \\\n      2       5\n     / \\     / \\\n    1   3   6   7\n\nWe traverse this tree and we print the value of each node we  visit it.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        },
        {
            "title": "Bilan M5 - Union find",
            "description": "Consider a graph made of 10 disjoint nodes (numbered from 0 to 9). We use a union-find data structure to represent this graph. At first, each node is contained in a partition named after the node. Thus, the representation of the graph in the array ``id[]`` is:\n\n::\n\n    0 1 2 3 4 5 6 7 8 9\n\nThe following questions will ask you to type the representation of the graph after we use the **quick-find** algorithm to add an edge between 2 nodes. You must type this representation in the same way it was typed above.\n\n**Note:** When we join ``p-q`` with the quick-find algorithm, the convention is to change ``id[p]`` (and potentially other entries) but not ``id[q]``.",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ]
        },
        {
            "title": "Bilan M3 - Binary Search Tree",
            "description": "Etant donné un arbre de recherche binaire, dont les noeuds implémentent l'interface Node:\n\n.. code-block:: java\n\n    interface Node {\n        /**\n          * @return la valeur contenue dans ce noeud\n          */\n        int getValue();\n\n        /**\n         * @return Le noeud situe a gauche (dont la valeur est < que la valeur actuelle) s'il existe, null sinon\n         */\n        Node getLeft();\n\n        /**\n          * @return Le noeud situe a droite (dont la valeur est > que la valeur actuelle) s'il existe, null sinon\n          */\n        Node getRight();\n    }\n\nL'on vous demande de fournir le **corps** de la fonction *ceil*, qui trouve dans l'arbre le plus petit élément plus grand ou égal à `value` (donc soit l'élément lui-même soit l'élément situé directement après par ordre de grandeur). Si un tel élément n'existe pas, elle doit retourner `null`.\n\n`Un projet Eclipse contenant des tests basiques vous est fourni en cliquant sur ce lien. <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016bst/project.zip>`_",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ]
        },
        {
            "title": "Bilan M3 - Questions à choix multiples",
            "description": "",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ]
        }
    ],
    "own_categories": {
        "0": "Skill",
        "1": "Misconception",
        "2": "Category"
    },
    "extraction_date": "2019-11-26T08:41:43.913Z",
    "url": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms"
}