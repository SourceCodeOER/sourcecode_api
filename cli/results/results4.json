{
    "exercises": [
        {
            "title": "Bilan Hashing",
            "description": "Etant donné une fonction de hachage\r\n$h(\\\\left\\[v\\_0 \\\\cdots v\\_n \\\\right\\]) = \\\\sum\\_{i=0}^{n} v\\_i R^{(n-i-1)} \\\\% M$\r\ndans laquelle \\[*v*<sub>0</sub>⋯*v*<sub>*n*</sub>\\] dénote un vecteur de\r\nbit et *R* et *M* sont des facteurs constants.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_hashing",
            "archive_properties": {
                "folders": [
                    "bilan_hashing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular LinkedList",
            "description": "Context\r\n=======\r\n\r\n[Description](bilan_m1/bilan_m1.pdf) of the implementation exercise and\r\ninteresting questions to improve your skills.\r\n\r\nFill-in the body of each method (TODO) below in the corresponding\r\ntextfield. grade: 50% for the correctness of your implementation\r\n(correct or not), 50% for the efficiency (efficient or not).\r\n\r\n``` java\r\npublic class NodeQueue<E> implements Queue<E> {\r\n\r\n    // Variables d’instance\r\n\r\n    private Node<E> marker;\r\n    private int size;\r\n\r\n\r\n    @Override\r\n    public int size() {\r\n        // TODO\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public boolean isEmpty() {\r\n        // TODO\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public E front() throws QueueEmptyException {\r\n        // TODO\r\n        return null;\r\n    }\r\n\r\n    @Override\r\n    public void enqueue(E element) {\r\n        // TODO\r\n\r\n    }\r\n\r\n    @Override\r\n    public E dequeue() throws QueueEmptyException {\r\n        // TODO\r\n        return null;\r\n    }\r\n}\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 1"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m1",
            "archive_properties": {
                "folders": [
                    "bilan_m1"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "Context\r\n=======\r\n\r\nAssume the following 5x5 matrix:\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nrepresented in the array here under:\r\n\r\n<img src=\"bilan_m2_global_warming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nEach entry of the matrix represents an altitude. The objective is to\r\nimplement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that\r\nthe method described in <span class=\"title-ref\">GlobalWarming</span>\r\ngiven next.\r\n\r\nGiven a global water level, all the positions of the matrix with a value\r\n&lt;= the water level are flooded (under the water) and thus unsafe. So\r\nassuming the water level is 3, all the safe points are green.\r\n\r\nThe methods you must implement is\r\n\r\n-   the computations of the number of safe-points given a specified\r\n    water level\r\n\r\n<!-- -->\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n\r\n    final int[][] altitude;\r\n\r\n    /**\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     */\r\n    public GlobalWarming(int[][] altitude) {\r\n        this.altitude = altitude;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param waterLevel\r\n     * @return the number of entries in altitude matrix that would be above\r\n     *         the specified waterLevel.\r\n     *         Warning: this is not the waterLevel given in the constructor/\r\n     */\r\n    public abstract int nbSafePoints(int waterLevel);\r\n\r\n}\r\n```\r\n\r\nPreliminary exercises\r\n=====================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab);\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m2_global_warming",
            "archive_properties": {
                "folders": [
                    "bilan_m2_global_warming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Incremental Hash",
            "description": "La fonction de Hash calculée sur le sous tableau t\\[from,...,from+M-1\\]\r\nest calculée comme suit:\r\n\r\n$hash(\\[from,...,from+M-1\\])= \\\\left( \\\\sum\\_{i=0}^{M-1} t\\[from+i\\] \\\\cdot R^{(M-1-i)}\\\\right)\\\\%Q$\r\n\r\nLe code pour calculer cette fonction de hash vous est donné. Nous vous\r\ndemandons de calculer\r\n*h**a**s**h*(\\[*f**r**o**m*, ..., *f**r**o**m* + *M* − 1\\]) au départ de\r\n*h**a**s**h*(\\[*f**r**o**m* − 1, ..., *f**r**o**m* + *M* − 2\\]) en O(1).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 4"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m4_incrementalhash",
            "archive_properties": {
                "folders": [
                    "bilan_m4_incrementalhash"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Huffman",
            "description": "Vous devez calculer un arbre de Huffman au départ de la fréquence donnée\r\npour chacune des R lettres (characters).\r\n\r\nPour rappel, dans un arbre de Huffman nous avons que *la somme de la\r\nfréquence associée à chaque feuille multipliée par la profondeur de\r\ncelle-ci est minimale*.\r\n\r\nPar exemple, étant donné les fréquences suivantes:\r\n\r\n<img src=\"bilan_m5_huffman/huffmanin.png\" class=\"align-center\" width=\"500\" alt=\"Input frequencies\" />\r\n\r\nun arbre de Huffman pourrait être:\r\n\r\n<img src=\"bilan_m5_huffman/huffmanout.png\" class=\"align-center\" width=\"500\" alt=\"Huffman tree\" />\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m5_huffman",
            "archive_properties": {
                "folders": [
                    "bilan_m5_huffman"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Connected Components",
            "description": "L'API de la classe [Graph](bilan_m6_cc/javadoc.zip).\r\n\r\nL'API de [Java](https://docs.oracle.com/javase/8/docs/api/).\r\n\r\n``` java\r\npublic class ConnectedComponents {\r\n  /**\r\n   * @return the number of connected components in g\r\n   */\r\n  public static int numberOfConnectedComponents(Graph g) {\r\n    // TODO\r\n    return 0;\r\n  }\r\n}\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/bilan_m6_cc",
            "archive_properties": {
                "folders": [
                    "bilan_m6_cc"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Quizz: Closest Pair",
            "description": "Implémentez un algorithme qui reçoit en entrée un tableau d'entiers et\r\nqui trouve deux valeurs issues de tableau dont la somme se rapproche le\r\nplus d'une valeur entière donnée *x*. Soiet (*a*, *b*) les deux valeurs\r\ntrouvées, celles-ci doivent donc minimiser |*x* − (*a* + *b*)|. Les deux\r\nvaleurs peuvent correspondre à la même entrée du tableau.\r\n\r\nPar exemple pour le tableau suivant\r\n\r\n``` java\r\nint [] input = new int [] {5,10,1,75,150,151,155,18,75,50,30};\r\n```\r\n\r\n-   x=20, il faut retourner \\[10,10\\].\r\n-   x=153, il faut retrouner \\[1,151\\]\r\n-   x=13, il faut retrouner \\[1,10\\]\r\n-   x=140 il faut retourner \\[75,75\\]\r\n-   x=170 il faut retourner \\[18,151\\]\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/closestpair/project.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "midterm"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/closestpair",
            "archive_properties": {
                "folders": [
                    "closestpair"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "LinearProbing",
            "description": "Dans ce exercice il vous est demandé d'implémenter les fonctions\r\n`resize`, `put` et `get` d'une table de symbole basé sur le hashage par\r\nLinear Probing.\r\n\r\nPour cela la classe suivant vous a été donné. Vous devez completer les\r\n*TODO*.\r\n\r\n``` java\r\nimport java.util.Arrays;\r\n\r\n/**\r\n* Symbol-table implementation with linear-probing hash table.\r\n*/\r\npublic class LinearProbingHashST<Key, Value> {\r\n\r\nprivate int n;           // number of key-value pairs in the symbol table\r\nprivate int m;           // size of linear probing table\r\nprivate Key[] keys;      // the keys\r\nprivate Value[] vals;    // the values\r\n\r\n\r\n/**\r\n * Initializes an empty symbol table.\r\n */\r\npublic LinearProbingHashST() {this(16);}\r\n\r\n /**\r\n * Initializes an empty symbol table with the specified initial capacity.\r\n */\r\npublic LinearProbingHashST(int capacity) {\r\n    m = capacity;\r\n    n = 0;\r\n    keys = (Key[])   new Object[m];\r\n    vals = (Value[]) new Object[m];\r\n}\r\n\r\npublic int size() {return n;}\r\npublic boolean isEmpty() {return size() == 0;}\r\n\r\n// hash function for keys - returns value between 0 and M-1\r\nprivate int hash(Key key) {\r\n    return (key.hashCode() & 0x7fffffff) % m;\r\n}\r\n\r\n/**\r\n* resizes the hash table to the given capacity by re-hashing all of the keys\r\n*/\r\nprivate void resize(int capacity) {\r\n    //TODO STUDENT\r\n}\r\n\r\n/**\r\n* Inserts the specified key-value pair into the symbol table, overwriting the old\r\n* value with the new value.\r\n*/\r\npublic void put(Key key, Value val) {\r\n    //TODO STUDENT\r\n}\r\n\r\n/**\r\n* Returns the value associated with the specified key.\r\n*/\r\npublic Value get(Key key) {\r\n    //TODO STUDENT\r\n}\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/EXAM0119LinearProbing/LSINF1121_EXAM0119_LinearProbing.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "exam"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/EXAM0119LinearProbing",
            "archive_properties": {
                "folders": [
                    "EXAM0119LinearProbing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "Context\r\n=======\r\n\r\nAssume the following 5x5 matrix:\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nrepresented in the array here under:\r\n\r\n<img src=\"globalwarming_graph/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nEach entry of the matrix represents an altitude. The objective is to\r\nimplement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that\r\nimplements all the methods described in <span\r\nclass=\"title-ref\">GlobalWarming</span> given next.\r\n\r\nA global water level specified in the constructor models the fact that\r\nall the positions of the matrix with a value &lt;= the water level are\r\nflooded (under the water) and thus unsafe. In the above example, the\r\nwater level is 3, all the safe points are green.\r\n\r\nThe method you must implement is the computation of the shortest path\r\nbetween two positions on a same island\r\n\r\nwe assume that points are **only connected vertially or horizontally**.\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x && p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry <= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param p1 a safe point with valid coordinates on altitude matrix\r\n     * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\r\n     * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\r\n     *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\r\n     */\r\n    public abstract List<Point> shortestPath(Point p1, Point p2);\r\n\r\n}\r\n```\r\n\r\nPreliminary exercises\r\n=====================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);\r\n```\r\n\r\n<img src=\"globalwarming_graph/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_graph",
            "archive_properties": {
                "folders": [
                    "globalwarming_graph"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming",
            "description": "Context\r\n=======\r\n\r\nAssume the following 5x5 matrix:\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nrepresented in the array here under:\r\n\r\n<img src=\"globalwarming_unionfind/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nEach entry of the matrix represents an altitude. The objective is to\r\nimplement a class <span class=\"title-ref\">GlobalWarmingImpl</span> that\r\nimplements all the methods described in <span\r\nclass=\"title-ref\">GlobalWarming</span> given next.\r\n\r\nA global water level specified in the constructor models the fact that\r\nall the positions of the matrix with a value &lt;= the water level are\r\nflooded (under the water) and thus unsafe. In the above example, the\r\nwater level is 3, all the safe points are green.\r\n\r\nThe methods you must implement are\r\n\r\n-   the number of islands\r\n-   a test to verify if two positions are on the same island\r\n\r\nwe assume that points are **only connected vertially or horizontally**.\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x && p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry <= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     * An island is a connected components of safe points wrt to waterLevel\r\n     * @return the number of islands\r\n     */\r\n    public abstract int nbIslands();\r\n\r\n    /**\r\n     *\r\n     * @param p1 a point with valid coordinates on altitude matrix\r\n     * @param p2 a point with valid coordinates on altitude matrix\r\n     * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\r\n     *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\r\n     */\r\n    public abstract boolean onSameIsland(Point p1, Point p2);\r\n\r\n\r\n}\r\n```\r\n\r\nPreliminary exercises\r\n=====================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);\r\n```\r\n\r\n<img src=\"globalwarming_unionfind/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/globalwarming_unionfind",
            "archive_properties": {
                "folders": [
                    "globalwarming_unionfind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Linked List Stack (Implem)",
            "description": "Il vous est demandé d'implémenter l'interface suivante, représentant une\r\npile, en utilisant une liste simplement chainée. Vous devriez avoir au\r\nmoins un constructeur sans argument, créant une pile vide.\r\n\r\nNote: utiliser *java.util.Stack&lt;E&gt;* est interdit!\r\n\r\n``` java\r\nimport java.util.EmptyStackException;\r\n\r\npublic interface Stack<E> {\r\n\r\n    public boolean empty();\r\n\r\n    public E peek() throws EmptyStackException;\r\n\r\n    public E pop() throws EmptyStackException;\r\n\r\n    public void push(E item);\r\n\r\n}\r\n```\r\n\r\n``` java\r\nimport java.util.EmptyStackException;\r\n\r\npublic class MyStack<E> implements Stack<E> {\r\n\r\n    private Node<E> top;        // the node on the top of the stack\r\n    private int size;        // size of the stack\r\n\r\n    // helper linked list class\r\n    private class Node<E> {\r\n        private E item;\r\n        private Node<E> next;\r\n\r\n        public Node(E element, Node<E> next) {\r\n            this.item = element;\r\n            this.next = next;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Tests if this stack is empty\r\n    */\r\n    @Override\r\n    public boolean empty() {\r\n        // TODO STUDENT: Implement empty method\r\n    }\r\n\r\n    /**\r\n    * Looks at the object at the top of this stack\r\n    * without removing it from the stack\r\n    */\r\n    @Override\r\n    public E peek() throws EmptyStackException {\r\n        // TODO STUDENT: Implement peek method\r\n    }\r\n\r\n    /**\r\n    * Removes the object at the top of this stack\r\n    * and returns that object as the value of this function\r\n    */\r\n    @Override\r\n    public E pop() throws EmptyStackException {\r\n        // TODO STUDENT: Implement pop method\r\n    }\r\n\r\n    /**\r\n    * Pushes an item onto the top of this stack\r\n    * @param item the item to append\r\n    */\r\n    @Override\r\n    public void push(E item) {\r\n        // TODO STUDENT: Implement push method\r\n\r\n    }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/m1stack/LSINF1121_PART1_Stack.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stack",
            "archive_properties": {
                "folders": [
                    "m1stack"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Write Unit tests Stack (Implem)",
            "description": "Rappelez-vous de l'interface Stack :\r\n\r\n``` java\r\nimport java.util.EmptyStackException;\r\n\r\npublic interface Stack<E> {\r\n\r\n    public boolean empty();\r\n\r\n    public E peek() throws EmptyStackException;\r\n\r\n    public E pop() throws EmptyStackException;\r\n\r\n    public void push(E item);\r\n\r\n}\r\n```\r\n\r\nIl vous est demandé d'écrire des tests unitaire (en utilisant JUnit)\r\nafin de vérifier si une implémentation particulière de cette interface\r\nest correcte.\r\n\r\nVoici un modèle simple que vous pouvez utiliser pour écrire vos tests\r\n(vous pouvez utiliser d'autres types que des String, bien sûr !) :\r\n\r\n``` java\r\nimport org.junit.Test;\r\nimport static org.junit.Assert.assertEquals;\r\n\r\npublic class StackTests {\r\n\r\n    @Test\r\n    public void firstTest() {\r\n        Stack<Integer> stack = new MyStack<Integer>();\r\n        stack.push(1);\r\n        assertEquals(new Integer(1), stack.pop());\r\n    }\r\n\r\n    @Test\r\n    public void secondTest() {\r\n        // ... TODO ...\r\n    }\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/m1stacktests/LSINF1121_PART1_Stack.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Hardy",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m1stacktests",
            "archive_properties": {
                "folders": [
                    "m1stacktests"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/m2bilanqcm",
            "archive_properties": {
                "folders": [
                    "m2bilanqcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Median",
            "description": "Nous vous donnons l'API d'une classe Vector permettant d'accéder,\r\nmodifier et interchanger deux élements en temps constant. Votre tâche\r\nest d'implémenter une méthode permettant de calculer la médiane d'un\r\nVecteur.\r\n\r\n``` java\r\npublic interface Vector {\r\n    // taille du vecteur\r\n    public int size();\r\n    // mets la valeur v à l'indice i du vecteur\r\n    public void set(int i, int v);\r\n    // renvoie la valeur à l'indice i du vecteur\r\n    public int get(int i);\r\n    // échange les valeurs aux positions i et j\r\n    public void swap(int i, int j);\r\n\r\n}\r\n```\r\n\r\n[Un projet Eclipse contenant des tests basiques vous est fourni en\r\ncliquant sur ce\r\nlien.](https://inginious.info.ucl.ac.be/course/LSINF1121-2016/median/project.zip)\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/median",
            "archive_properties": {
                "folders": [
                    "median"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular linkedlist (Implem)",
            "description": "On s’intéresse à l'implémentation d'une\r\n`liste simplement chaînée circulaire`, c’est-à-dire une liste pour\r\nlaquelle la dernière position de la liste fait référence, comme position\r\nsuivante, à la première position de la liste.\r\n\r\n![image](p1circularlinkedlist/CircularLinkedList.png)\r\n\r\nL’ajout d’un nouvel élément dans la file (méthode `enqueue`) se fait en\r\nfin de liste et le retrait (méthode `remove`) se fait a un <span\r\nclass=\"title-ref\">index</span> particulier de la liste. Une (seule)\r\nréférence sur la fin de la liste (`last`) est nécessaire pour effectuer\r\ntoutes les opérations sur cette file.\r\n\r\nIl vous est donc demander d'implémenter cette liste simplement chaînée\r\ncirculaire à partir de la classe `CircularLinkedList.java` où vous devez\r\ncompleter (*TODO STUDENT*) les méthodes d'ajout (`enqueue`) et de\r\nretrait (`remove`) ainsi qu'un itérateur (`ListIterator`) qui permet de\r\nparcourir la liste en FIFO. *Attention:* un itérateur ne peut être\r\nmodifié au cours de son utilisation.\r\n\r\n``` java\r\npackage student;\r\n\r\nimport java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\npublic class CircularLinkedList<Item> implements Iterable<Item> {\r\n private long nOp = 0; // count the number of operations\r\n private int n;          // size of the stack\r\n private Node  last;   // trailer of the list\r\n\r\n // helper linked list class\r\n private class Node {\r\n     private Item item;\r\n     private Node next;\r\n }\r\n\r\n public CircularLinkedList() {\r\n     last = null;\r\n     n = 0;\r\n }\r\n\r\n public boolean isEmpty() { return n == 0; }\r\n\r\n public int size() { return n; }\r\n\r\n private long nOp() { return nOp; }\r\n\r\n /**\r\n  * Append an item at the end of the list\r\n  * @param item the item to append\r\n  */\r\n public void enqueue(Item item) {\r\n     // TODO STUDENT: Implement add method\r\n }\r\n\r\n /**\r\n  * Removes the element at the specified position in this list.\r\n  * Shifts any subsequent elements to the left (subtracts one from their indices).\r\n  * Returns the element that was removed from the list.\r\n  */\r\n public Item remove(int index) {\r\n     // TODO STUDENT: Implement remove method\r\n }\r\n\r\n /**\r\n  * Returns an iterator that iterates through the items in FIFO order.\r\n  * @return an iterator that iterates through the items in FIFO order.\r\n  */\r\n public Iterator<Item> iterator() {\r\n     return new ListIterator();\r\n }\r\n\r\n /**\r\n  * Implementation of an iterator that iterates through the items in FIFO order.\r\n  *\r\n  */\r\n private class ListIterator implements Iterator<Item> {\r\n     // TODO STUDDENT: Implement the ListIterator\r\n }\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/p1circularlinkedlist/LSINF1121CircularLinkedList.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/p1circularlinkedlist",
            "archive_properties": {
                "folders": [
                    "p1circularlinkedlist"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Circular linkedlist (Implem)",
            "description": "On s’intéresse à l'implémentation d'une\r\n`liste simplement chaînée circulaire`, c’est-à-dire une liste pour\r\nlaquelle la dernière position de la liste fait référence, comme position\r\nsuivante, à la première position de la liste.\r\n\r\n<figure>\r\n<img src=\"Part1CircularLinkedList/CircularLinkedList.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n\r\nL’ajout d’un nouvel élément dans la file (méthode `enqueue`) se fait en\r\nfin de liste et le retrait (méthode `remove`) se fait a un <span\r\nclass=\"title-ref\">index</span> particulier de la liste. Une (seule)\r\nréférence sur la fin de la liste (`last`) est nécessaire pour effectuer\r\ntoutes les opérations sur cette file.\r\n\r\nIl vous est donc demander d'implémenter cette liste simplement chaînée\r\ncirculaire à partir de la classe `CircularLinkedList.java` où vous devez\r\ncompleter (*TODO STUDENT*):\r\n\r\n-   la méthode d'ajout (`enqueue`);\r\n-   la méthode de retrait (`remove`) \\[L'exception\r\n    `IndexOutOfBoundsException` est lancée quand la valeur de l'index\r\n    n'est pas comprise en 0 et size()-1\\];\r\n-   l'itérateur (`ListIterator`) qui permet de parcourir la liste en\r\n    FIFO.\r\n\r\n*Attention:* L'itérateur devra lancer des exceptions dans les cas\r\nsuivants:\r\n\r\n-   étant donnée que le `remove` est optionnel dans\r\n    l'[API](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)\r\n    , l'iterateur devra juste lancer un `UnsupportedOperationException`\r\n    en cas d'appel du `remove`;\r\n-   étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en\r\n    train d'itérer, l'iterateur devra lancer un\r\n    `ConcurrentModificationException` dans ce cas dans le `next` et le\r\n    `hasNest`;\r\n-   si le `next` est appelé alors qu'il n'y a plus de prochain élément,\r\n    l'iterateur devra lancer un `NoSuchElementException`.\r\n\r\n<!-- -->\r\n\r\n``` java\r\nimport java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\n\r\npublic class CircularLinkedList<Item> implements Iterable<Item> {\r\n private long nOp = 0; // count the number of operations\r\n private int n;          // size of the stack\r\n private Node  last;   // trailer of the list\r\n\r\n // helper linked list class\r\n private class Node {\r\n     private Item item;\r\n     private Node next;\r\n }\r\n\r\n public CircularLinkedList() {\r\n     last = null;\r\n     n = 0;\r\n }\r\n\r\n public boolean isEmpty() { return n == 0; }\r\n\r\n public int size() { return n; }\r\n\r\n private long nOp() { return nOp; }\r\n\r\n /**\r\n  * Append an item at the end of the list\r\n  * @param item the item to append\r\n  */\r\n public void enqueue(Item item) {\r\n     // TODO STUDENT: Implement add method\r\n }\r\n\r\n /**\r\n  * Removes the element at the specified position in this list.\r\n  * Shifts any subsequent elements to the left (subtracts one from their indices).\r\n  * Returns the element that was removed from the list.\r\n  */\r\n public Item remove(int index) {\r\n     // TODO STUDENT: Implement remove method\r\n }\r\n\r\n /**\r\n  * Returns an iterator that iterates through the items in FIFO order.\r\n  * @return an iterator that iterates through the items in FIFO order.\r\n  */\r\n public Iterator<Item> iterator() {\r\n     return new ListIterator();\r\n }\r\n\r\n /**\r\n  * Implementation of an iterator that iterates through the items in FIFO order.\r\n  *\r\n  */\r\n private class ListIterator implements Iterator<Item> {\r\n     // TODO STUDENT: Implement the ListIterator\r\n }\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part1CircularLinkedList/LSINF1121_PART1_CircularLinkedList.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part1CircularLinkedList",
            "archive_properties": {
                "folders": [
                    "Part1CircularLinkedList"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "Context\r\n=======\r\n\r\nSupposons la matrice 5x5 suivante :\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nreprésentée dans le tableau ci-dessous :\r\n\r\n<img src=\"Part2GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nChaque entrée de la matrice représente une altitude. L'objectif est\r\nd'implémenter une classe `GlobalWarmingImpl` qui étend la méthode <span\r\nclass=\"title-ref\">GlobalWarming</span> décrite ci-dessous.\r\n\r\nCompte tenu d'un niveau d'eau global, toutes les positions de la matrice\r\nayant une valeur *&lt;=* au niveau d'eau sont inondées et donc peu\r\nsûres. Donc, en supposant que le niveau d'eau est de *3*, tous les\r\npoints sûrs sont en vert (dans la représentation ci-dessus).\r\n\r\nLa méthode que vous devez implémentez est `nbSafePoints`\r\n\r\n-   le calcul du nombre de points de sécurité pour un niveau d'eau donné\r\n\r\n<!-- -->\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n\r\n    final int[][] altitude;\r\n\r\n    /**\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     */\r\n    public GlobalWarming(int[][] altitude) {\r\n        this.altitude = altitude;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param waterLevel\r\n     * @return the number of entries in altitude matrix that would be above\r\n     *         the specified waterLevel.\r\n     *         Warning: this is not the waterLevel given in the constructor/\r\n     */\r\n    public abstract int nbSafePoints(int waterLevel);\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part2GlobalWarming/LSINF1121_PART2_GlobalWarming.zip).\r\n\r\nExercices préliminaires\r\n=======================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab);\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part2GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Median (implem)",
            "description": "Nous vous donnons l'API d'une classe Vector permettant d'accéder,\r\nmodifier et interchanger deux élements en temps constant. Votre tâche\r\nest d'implémenter une méthode permettant de calculer la médiane d'un\r\nVecteur.\r\n\r\n``` java\r\npublic interface Vector {\r\n    // taille du vecteur\r\n    public int size();\r\n    // mets la valeur v à l'indice i du vecteur\r\n    public void set(int i, int v);\r\n    // renvoie la valeur à l'indice i du vecteur\r\n    public int get(int i);\r\n    // échange les valeurs aux positions i et j\r\n    public void swap(int i, int j);\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part2Median/LSINF1121_PART2_Median.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2Median",
            "archive_properties": {
                "folders": [
                    "Part2Median"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Merge Sort (implem)",
            "description": "Considérons l'algorithme de tri (descendant) `Merge Sort`.\r\n\r\n``` java\r\npublic class MergeSort {\r\n    /**\r\n     * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\r\n     * Post-conditions: a[lo..hi] is sorted\r\n     */\r\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\r\n        for (int k = lo; k <= hi; k++) {\r\n            aux[k] = a[k];\r\n        }\r\n\r\n        int i = lo;\r\n        int j = mid + 1;\r\n        for (int k = lo; k <= hi; k++) {\r\n            if (i > mid) {\r\n                a[k] = aux[j++];\r\n            } else if (j > hi) {\r\n                a[k] = aux[i++];\r\n            } else if (aux[j].compareTo(aux[i]) < 0) {\r\n                a[k] = aux[j++];\r\n            } else {\r\n                a[k] = aux[i++];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\r\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Rearranges the array in ascending order, using the natural order\r\n     */\r\n    public static void sort(Comparable[] a) {\r\n        // TODO\r\n    }\r\n}\r\n```\r\n\r\n**Note:** Les questions suivantes vous demanderont d'implémenter la\r\nfonction left out. Vous n'avez pas besoin de mettre les accolades\r\n(`{ }`) entourant le corps de la fonction dans votre réponse.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part2MergeSort/LSINF1121_PART2_MergeSort.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2MergeSort",
            "archive_properties": {
                "folders": [
                    "Part2MergeSort"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2QCM",
            "archive_properties": {
                "folders": [
                    "Part2QCM"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union Intervals (implem)",
            "description": "Etant donné un tableau d'intervalles (fermés), Il vous est demandé\r\nd'implémenter l'opération `union`. Cette opération retournera le tableau\r\nminimal d'intervalles triés couvrant exactement l'union des points\r\ncouverts par les intervalles d'entrée.\r\n\r\nPar exemple, l'union des intervalles *\\[7,9\\],\\[5,8\\],\\[2,4\\]* est\r\n*\\[2,4\\],\\[5,9\\]*.\r\n\r\nLa classe `Interval` permetant de stocker les intervalles vous est\r\nfourni et se présente comme suit (vous pouvez l'utiliser directement\r\ndans votre code):\r\n\r\n``` java\r\npublic class Interval implements Comparable<Interval> {\r\n\r\n    final int min, max;\r\n    public Interval(int min, int max) {\r\n        assert(min <= max);\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        return ((Interval) obj).min == min && ((Interval) obj).max == max;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"[\"+min+\",\"+max+\"]\";\r\n    }\r\n\r\n    @Override\r\n    public int compareTo(Interval o) {\r\n        if (min < o.min) return -1;\r\n        else if (min == o.min) return max - o.max;\r\n        else return 1;\r\n    }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part2UnionIntervals/LSINF1121_PART2_UnionIntervals.zip).\r\n\r\nNous vous conseillons de le télécharger d'implémenter/tester avant de\r\nsoumettre ce qui vous est demandé.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2UnionIntervals",
            "archive_properties": {
                "folders": [
                    "Part2UnionIntervals"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree (implem)",
            "description": "Etant donné un arbre de recherche binaire, dont les noeuds implémentent\r\nl'interface Node:\r\n\r\n``` java\r\ninterface Node {\r\n    /**\r\n      * @return the value contained in this node\r\n      */\r\n    int getValue();\r\n\r\n    /**\r\n     * @return the node on the left (whose value is < than the current value)\r\n     * if it exists, null if not\r\n     */\r\n    Node getLeft();\r\n\r\n    /**\r\n      * @return the node on the right (whose value is > than the current value)\r\n      * if it exists, null if not\r\n      */\r\n    Node getRight();\r\n}\r\n```\r\n\r\nL'on vous demande de fournir le **corps** de la fonction *ceil*, qui\r\ntrouve dans l'arbre le plus petit élément plus grand ou égal à <span\r\nclass=\"title-ref\">value</span> (donc soit l'élément lui-même soit\r\nl'élément situé directement après par ordre de grandeur). Si un tel\r\nélément n'existe pas, elle doit retourner <span\r\nclass=\"title-ref\">null</span>.\r\n\r\nPar exemple si on a ce BST,\r\n\r\n<figure>\r\n<img src=\"PART3Bst/bst.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n\r\n-   ceil(11) nous renverra 11,\r\n-   ceil(4) nous renverra 8,\r\n-   et ceil(21) nous renverra null.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/PART3Bst/LSINF1121_PART3_BinarySearchTree.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Bst",
            "archive_properties": {
                "folders": [
                    "PART3Bst"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree Iterator (implem)",
            "description": "On s’intéresse à l'implémentation d'un itérateur (`BSTIterator`) qui\r\npermet de traverser un `Binary Search Tree` dans l'ordre croissant\r\n(*In-order transversal*).\r\n\r\nPar exemple si on a ce BST,\r\n\r\n<figure>\r\n<img src=\"PART3OrderedBstIterator/bst.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n\r\non veut le parcourir comme suit *\\[3,8,9,11,12,14,15,18,20\\]*\r\n\r\n*Attention:* L'itérateur devra lancer des exceptions dans les cas\r\nsuivants:\r\n\r\n-   étant donnée qu'on ne peut modifier l'itérateur alors qu'on est en\r\n    train d'itérer, l'iterateur devra lancer un\r\n    `ConcurrentModificationException` dans ce cas dans le `next` et le\r\n    `hasNest`;\r\n-   si le `next` est appelé alors qu'il n'y a plus de prochain élément,\r\n    l'iterateur devra lancer un `NoSuchElementException`.\r\n\r\n<!-- -->\r\n\r\n``` java\r\nimport java.util.ConcurrentModificationException;\r\nimport java.util.Iterator;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Stack;\r\n\r\n   public class BST<Key extends Comparable<Key>, Value> implements Iterable<Key> {\r\n    private Node root;             // root of BST\r\n\r\n    private class Node {\r\n        private final Key key;       // sorted by key\r\n        private Value val;           // associated data\r\n        private Node left, right;    // left and right subtrees\r\n        private int size;            // number of nodes in subtree\r\n\r\n        public Node(Key key, Value val, int size) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.size = size;\r\n        }\r\n\r\n        public int getSize() {\r\n            return size;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes an empty symbol table.\r\n     */\r\n    public BST() {}\r\n\r\n    /**\r\n     * Returns true if this symbol table is empty.\r\n     * @return {@code true} if this symbol table is empty; {@code false} otherwise\r\n     */\r\n    public boolean isEmpty() {\r\n        return size() == 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of key-value pairs in this symbol table.\r\n     * @return the number of key-value pairs in this symbol table\r\n     */\r\n    public int size() {\r\n        return size(root);\r\n    }\r\n\r\n    // return number of key-value pairs in BST rooted at x\r\n    private int size(Node x) {\r\n        if (x == null) return 0;\r\n        else return x.size;\r\n    }\r\n\r\n    public void inOrder(){\r\n        inOrder(root);\r\n    }\r\n    private void inOrder(Node x) {\r\n        if (x == null) return;\r\n\r\n        inOrder(x.left);\r\n        System.out.println(x.key+\"=>\"+x.val);\r\n        inOrder(x.right);\r\n    }\r\n\r\n    /**\r\n     * Returns the value associated with the given key.\r\n     *\r\n     * @param  key the key\r\n     * @return the value associated with the given key if the key is in the symbol table\r\n     *         and {@code null} if the key is not in the symbol table\r\n     */\r\n    public Value get(Key key) {\r\n        return get(root, key);\r\n    }\r\n\r\n    private Value get(Node x, Key key) {\r\n        if (x == null) return null;\r\n        int cmp = key.compareTo(x.key);\r\n        if      (cmp < 0) return get(x.left, key);\r\n        else if (cmp > 0) return get(x.right, key);\r\n        else              return x.val;\r\n    }\r\n\r\n    /**\r\n     * Search for key, update value if key is found. Grow table if key is new.\r\n     *\r\n     * @param  key the key\r\n     * @param  val the value\r\n     */\r\n    public void put(Key key, Value val) {\r\n        root = put(root, key, val);\r\n    }\r\n    private Node put(Node x, Key key, Value val) {\r\n        if (x == null) return new Node(key, val, 1);\r\n        int cmp = key.compareTo(x.key);\r\n        if      (cmp < 0) x.left  = put(x.left,  key, val);\r\n        else if (cmp > 0) x.right = put(x.right, key, val);\r\n        else              x.val   = val;\r\n        x.size = 1 + size(x.left) + size(x.right);\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns an iterator that iterates through the keys in Incresing order\r\n     * (In-Order transversal).\r\n     * @return an iterator that iterates through the items in FIFO order.\r\n     */\r\n    @Override\r\n    public Iterator<Key> iterator() {\r\n        return new BSTIterator();\r\n    }\r\n\r\n        /**\r\n  * Implementation of an iterator that iterates through the keys of BST in incresing order (In-order transversal).\r\n  *\r\n  */\r\n    private class BSTIterator implements Iterator<Key> {\r\n\r\n        // TODO STUDDENT: Implement the BSTIterator\r\n\r\n    }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/PART3OrderedBstIterator/LSINF1121_PART3_OrderedBstIterator.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3OrderedBstIterator",
            "archive_properties": {
                "folders": [
                    "PART3OrderedBstIterator"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Qcm",
            "archive_properties": {
                "folders": [
                    "PART3Qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Binary Trees",
            "description": "Consider this ordered binary tree:\r\n\r\n<figure>\r\n<img src=\"PART3QcmBt/bt.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n\r\nWe traverse this tree and we print the value of each node we visit it.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3QcmBt",
            "archive_properties": {
                "folders": [
                    "PART3QcmBt"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Red Black Tree",
            "description": "Prenons l'exemple d'un `Red-Black Tree` vide dans lequel on ajoute\r\nprogressivement des chiffres.\r\n\r\nLes questions suivantes vous demanderont d'écrire une représentation du\r\n`Red-Black Tree` au fur et à mesure que nous y ajouterons des objets.\r\n\r\nÉcrivez la réponse comme si vous lisiez le `Red-Black Tree` de gauche à\r\ndroite et de haut en bas (en ignorant les blancs possibles). Par\r\nexemple, si votre réponse est :\r\n\r\n<figure>\r\n<img src=\"PART3Rbt/rbt.png\" class=\"align-centeralign-center\" alt=\"\" />\r\n</figure>\r\n\r\nVous écririez:\r\n\r\n    6 24 7 1 3 5 9\r\n\r\nRemarquez comment le nœud 2-3 composé de `2`et `4` est écrit d'une\r\nmanière fusionnée (`24`).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3Rbt",
            "archive_properties": {
                "folders": [
                    "PART3Rbt"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Write Unit tests Red Black Tree",
            "description": "Il vous est demandé d'écrire des tests unitaire (en utilisant JUnit)\r\nafin de vérifier si une implémentation particulière d'un\r\n`Red-Black Tree` est correcte.\r\n\r\nVoici un modèle simple que vous pouvez utiliser pour écrire vos tests :\r\n\r\n> ``` java\r\n> import org.junit.Test;\r\n> import static org.junit.Assert.assertEquals;\r\n>\r\n> public class RedBlackTests {\r\n>\r\n>     @Test\r\n>     public void firstTest() {\r\n>         // ... TODO ...\r\n>     }\r\n>\r\n>     @Test\r\n>     public void secondTest() {\r\n>         // ... TODO ...\r\n>     }\r\n>\r\n> }\r\n> ```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/PART3WriteUnittestsRedBlackTree/LSINF1121_PART3_UnitTestsRedBlackTree.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Simon Teugels",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART3WriteUnittestsRedBlackTree",
            "archive_properties": {
                "folders": [
                    "PART3WriteUnittestsRedBlackTree"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Incremental Hash (implem)",
            "description": "La fonction de Hash calculée sur le sous tableau\r\n*t*\\[*f**r**o**m*, ..., *f**r**o**m* + *M* − 1\\] est calculée comme\r\nsuit:\r\n\r\n$hash(\\[from,...,from+M-1\\])= \\\\left( \\\\sum\\_{i=0}^{M-1} t\\[from+i\\] \\\\cdot R^{(M-1-i)}\\\\right)\\\\%Q$\r\n\r\nLe code pour calculer cette fonction de hash vous est donné. Nous vous\r\ndemandons de calculer\r\n*h**a**s**h*(\\[*f**r**o**m*, ..., *f**r**o**m* + *M* − 1\\]) au départ de\r\n*h**a**s**h*(\\[*f**r**o**m* − 1, ..., *f**r**o**m* + *M* − 2\\]) en O(1).\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part4IncrementalHash/LSINF1121_PART4_IncrementalHash.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4IncrementalHash",
            "archive_properties": {
                "folders": [
                    "Part4IncrementalHash"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Hashing",
            "description": "Etant donné une fonction de hachage:\r\n\r\n$h(\\\\left\\[v\\_0 \\\\cdots v\\_{n-1} \\\\right\\]) = \\\\sum\\\\limits\\_{i=0}^{n-1} v\\_i R^{(n-i-1)} \\\\% M$\r\n\r\ndans laquelle \\[*v*<sub>0</sub>⋯*v*<sub>*n* − 1</sub>\\] dénote un\r\nvecteur de bit et *R* et *M* sont des facteurs constants.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "xgillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "john Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmHashing",
            "archive_properties": {
                "folders": [
                    "Part4QcmHashing"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Rabin Karp",
            "description": "A la page 777 du livre \"Algorithms\" 4th edition, on vous propose\r\nl'implémentation suivante de l'algorithme de Rabin Karp.\r\n\r\n``` java\r\npublic class RabinKarp {\r\n  private String pat;      // the pattern  // needed only for Las Vegas\r\n  private long patHash;    // pattern hash value\r\n  private int m;           // pattern length\r\n  private long q;          // a large prime, small enough to avoid long overflow\r\n  private int R;           // radix\r\n  private long RM;         // R^(M-1) % Q\r\n\r\n  public RabinKarp(String pat) {\r\n      this.pat = pat;      // save pattern (needed only for Las Vegas)\r\n      R = 256;\r\n      m = pat.length();\r\n      q = longRandomPrime();\r\n\r\n      // precompute R^(m-1) % q for use in removing leading digit\r\n      RM = 1;\r\n      for (int i = 1; i <= m-1; i++)\r\n          RM = (R * RM) % q;\r\n      patHash = hash(pat, m);\r\n  }\r\n\r\n  // Compute hash for key[0..m-1].\r\n  private long hash(String key, int m) {\r\n      long h = 0;\r\n      for (int j = 0; j < m; j++)\r\n          h = (R * h + key.charAt(j)) % q;\r\n      return h;\r\n  }\r\n\r\n  // Monte Carlo\r\n  private boolean check(int i) {\r\n      return true;\r\n  }\r\n\r\n  // Returns the index of the first occurrrence of the pattern string in the text string.\r\n  public int search(String txt) {\r\n      int n = txt.length();\r\n      if (n < m) return n;\r\n      long txtHash = hash(txt, m);\r\n\r\n      // check for match at offset 0\r\n      if ((patHash == txtHash) && check(txt, 0))\r\n          return 0;\r\n\r\n      // check for hash match; if hash match, check for exact match\r\n      for (int i = m; i < n; i++) {\r\n          // Remove leading digit, add trailing digit, check for match.\r\n          txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\r\n          txtHash = (txtHash*R + txt.charAt(i)) % q;\r\n\r\n          // match\r\n          int offset = i - m + 1;\r\n          if ((patHash == txtHash) && check(txt, offset))\r\n              return offset;\r\n      }\r\n\r\n      // no match\r\n      return n;\r\n  }\r\n\r\n\r\n  // a random 31-bit prime\r\n  private static long longRandomPrime() {\r\n      BigInteger prime = BigInteger.probablePrime(31, new Random());\r\n      return prime.longValue();\r\n  }\r\n\r\n}\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmRk",
            "archive_properties": {
                "folders": [
                    "Part4QcmRk"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Rabin Karp of k patterns (implem)",
            "description": "On s'intéresse à l'algorithme de Rabin-Karp. On voudrait le modifier\r\nquelque peu pour déterminer si un mot parmi une liste (tous les mots\r\nsont de même longueur) est présent dans le texte.\r\n\r\nPour cela, vous devez modifier l'algorithme de Rabin-Karp qui se trouve\r\nci-dessous (Page 777 du livre).\r\n\r\nPlus précisément, on vous demande de modifier cette classe de manière à\r\navoir un constructeur de la forme:\r\n\r\n``` java\r\npublic RabinKarp(String[] pat)\r\n```\r\n\r\nDe plus la fonction `search` doit retourner l'indice du début du premier\r\nmot (parmi le tableau `pat`) trouvé dans le texte ou la taille du texte\r\nsi aucun mot n'aparait dans le texte.\r\n\r\nExemple: Si txt = “Here find interresting exercise for Rabin Karp” et\r\npat={“have”, “find”, “Karp”} la fonction `search` doit renvoyer 5 car le\r\nmot \"find\" présent dans le texte et dans la liste commence à l'indice 5.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part4RabinKarp/LSINF1121_PART4_RabinKarp.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4RabinKarp",
            "archive_properties": {
                "folders": [
                    "Part4RabinKarp"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Heap Push (implem)",
            "description": "Dans cette tâche on vous propose d'implémenter la fonction d'insertion\r\n`push()` d'un heap binaire.\r\n\r\n> La fonction push agit sur un tableau, nommé `contenu`, qui représente\r\n> un arbre, selon la méthode vue au cours: le noeud n°i de l'arbre a\r\n> pour enfant les indices 2\\*i et 2\\*i+1.\r\n\r\nil faut noter que dans le livre à la page 318 a été proposée le `MaxPQ`\r\nmais ici nous vous proposons de plutot réfléchir aux changements à\r\napporter à ce code pour implémenter un `MinPQ` notamment à la fonction\r\nd'insertion.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/PART5BinaryHeapPush/LSINF1121_PART5_BinaryHeapPush.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART5BinaryHeapPush",
            "archive_properties": {
                "folders": [
                    "PART5BinaryHeapPush"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "Context\r\n=======\r\n\r\nSupposons la matrice 5x5 suivante:\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nreprésentée dans le tableau ci-dessous :\r\n\r\n<img src=\"Part5GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nChaque entrée de la matrice représente une altitude. L'objectif est\r\nd'implémenter une classe <span\r\nclass=\"title-ref\">GlobalWarmingImpl</span> qui implémente toutes les\r\nméthodes décrites dans <span class=\"title-ref\">GlobalWarming</span>\r\ndonnées ci-dessous.\r\n\r\nUn niveau d'eau global spécifié dans le constructeur modélise le fait\r\nque toutes les positions de la matrice avec une valeur &lt;= le niveau\r\nd'eau sont inondées (sous l'eau) et donc dangereuses. Dans l'exemple\r\nci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.\r\n\r\nLes méthodes que vous devez implémenter sont les suivantes\r\n\r\n-   le nombre d'îles\r\n-   un test pour vérifier si deux positions sont sur la même île\r\n\r\nnous supposons que les points sont **uniquement connectés verticalement\r\nou horizontalement**.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part5GlobalWarming/LSINF1121_PART5_GlobalWarming.zip).\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x && p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry <= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     * An island is a connected components of safe points wrt to waterLevel\r\n     * @return the number of islands\r\n     */\r\n    public abstract int nbIslands();\r\n\r\n    /**\r\n     *\r\n     * @param p1 a point with valid coordinates on altitude matrix\r\n     * @param p2 a point with valid coordinates on altitude matrix\r\n     * @return true if p1 and p2 are on the same island, that is both p1 and p2 are safe wrt waterLevel\r\n     *        and there exists a path (vertical/horizontal moves) from p1 to p2 using only safe positions\r\n     */\r\n    public abstract boolean onSameIsland(Point p1, Point p2);\r\n\r\n\r\n}\r\n```\r\n\r\nPreliminary exercises\r\n=====================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);\r\n```\r\n\r\n<img src=\"Part5GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part5GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Heap",
            "description": "Considérons la structure de données `Heap` dans laquelle on ajoute\r\nprogressivement des nombres.\r\n\r\nLes questions suivantes vous demanderont d'écrire une représentation du\r\n`Heap` au fur et à mesure que nous y ajoutons des objets. Vous devez\r\nécrire le `Heap` comme s'il était stocké dans un tableau. Par exemple,\r\nsi votre réponse est :\r\n\r\n    9\r\n    / \\\r\n    5   8\r\n    / \\\r\n    4   3\r\n\r\nVous devriez écrire:\r\n\r\n    9 5 8 4 3\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Heap",
            "archive_properties": {
                "folders": [
                    "Part5Heap"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Huffman (implem)",
            "description": "Vous devez calculer un arbre de Huffman au départ de la fréquence donnée\r\npour chacune des R lettres (characters).\r\n\r\nPour rappel, dans un arbre de Huffman nous avons que *la somme de la\r\nfréquence associée à chaque feuille multipliée par la profondeur de\r\ncelle-ci est minimale*.\r\n\r\nPar exemple, étant donné les fréquences suivantes:\r\n\r\n<img src=\"Part5Huffman/huffmanin.png\" class=\"align-center\" width=\"500\" alt=\"Input frequencies\" />\r\n\r\nun arbre de Huffman pourrait être:\r\n\r\n<img src=\"Part5Huffman/huffmanout.png\" class=\"align-center\" width=\"500\" alt=\"Huffman tree\" />\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part5Huffman/LSINF1121_PART5_Huffman.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman",
            "archive_properties": {
                "folders": [
                    "Part5Huffman"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union find",
            "description": "Considérons un graphe composé de 10 nœuds disjoints (numérotés de 0 à\r\n9). Nous utilisons une structure de données union-find pour représenter\r\nce graphe. Dans un premier temps, chaque nœud est contenu dans une\r\npartition qui porte son nom. Ainsi, la représentation du graphique dans\r\nle tableau `id[]` est :\r\n\r\n    0 1 2 3 4 5 6 7 8 9\r\n\r\nLes questions suivantes vous demanderont de donner la représentation du\r\ngraphe après avoir utilisé l'algorithme **quick-find** pour ajouter une\r\narête entre 2 noeuds. Vous devez donner cette représentation de la même\r\nmanière qu'elle a été donnée ci-dessus.\r\n\r\n**Note:** Lorsque nous joignons `p-q` avec l'algorithme quick-find, la\r\nconvention est de changer `id[p]` (et éventuellement d'autres entrées)\r\nmais pas `id[q]`.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5UnionFind",
            "archive_properties": {
                "folders": [
                    "Part5UnionFind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "PART 6  - Breadth First Paths (implem)",
            "description": "Considérez cette classe, `BreadthFirstShortestPaths`, qui calcule le\r\nchemin le plus court entre plusieurs sources de nœuds et n'importe quel\r\nnœud dans un graphe non dirigé en utilisant un parcours BFS.\r\n\r\n``` java\r\n// TODO\r\n\r\npublic class BreadthFirstShortestPaths {\r\n\r\n    private static final int INFINITY = Integer.MAX_VALUE;\r\n    private boolean[] marked; // marked[v] = is there an s-v path\r\n    private int[] distTo;     // distTo[v] = number of edges shortest s-v path\r\n\r\n    /**\r\n     * Computes the shortest path between any\r\n     * one of the sources and very other vertex\r\n     * @param G the graph\r\n     * @param sources the source vertices\r\n     */\r\n     public BreadthFirstShortestPaths(Graph G, Iterable<Integer> sources) {\r\n         marked = new boolean[G.V()];\r\n         distTo = new int[G.V()];\r\n         for (int v = 0;v < G.V();v++) {\r\n             distTo[v] = INFINITY;\r\n         }\r\n         bfs(G, sources);\r\n     }\r\n\r\n     // Breadth-first search from multiple sources\r\n     private void bfs(Graph G, Iterable<Integer> sources) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between (at least one of) the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, and false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns the number of edges in a shortest path\r\n      * between one of the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return the number of edges in a shortest path\r\n      */\r\n     public int distTo(int v) {\r\n         // TODO\r\n     }\r\n}\r\n```\r\n\r\nLa classe `Graph` est déjà implémentée et la voici :\r\n\r\n``` java\r\npublic class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable<Integer> adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}\r\n```\r\n\r\n**Note:** Les questions suivantes vous demanderont d'implémenter tous\r\nles `TODO` de la classe `BreadthFirstShortestPaths`. Vous n'avez pas\r\nbesoin de mettre les accolades (`{ }`) entourant le corps de la fonction\r\ndans votre réponse.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6BreadthFirstPaths/LSINF1121_PART6_BreadthFirstShortestPaths.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6BreadthFirstPaths",
            "archive_properties": {
                "folders": [
                    "Part6BreadthFirstPaths"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Connected Components (implem)",
            "description": "Il vous ait demandé d'implémenter la classe des composants connexes\r\n`ConnectedComponent` étant donnée un graphe. La classe\r\n[Graph](Part6ConnectedComponents/javadoc.zip) disponible dans le code\r\nest celle de l'API de la classe\r\n[Java](https://docs.oracle.com/javase/8/docs/api/).\r\n\r\n``` java\r\npublic class ConnectedComponents {\r\n  /**\r\n   * @return the number of connected components in g\r\n   */\r\n  public static int numberOfConnectedComponents(Graph g) {\r\n    // TODO\r\n    return 0;\r\n  }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6ConnectedComponents/LSINF1121_PART6_ConnectedComponents.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "psc",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6ConnectedComponents",
            "archive_properties": {
                "folders": [
                    "Part6ConnectedComponents"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Depth First Paths (implem)",
            "description": "Considérez cette classe, `DepthFirstPaths`, qui calcule les chemins vers\r\nn'importe quel noeud connecté à partir d'un noeud source `s` dans un\r\ngraphe non dirigé en utilisant un parcours DFS.\r\n\r\n``` java\r\n// TODO\r\n\r\npublic class DepthFirstPaths {\r\n    private boolean[] marked; // marked[v] = is there an s-v path?\r\n    private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\r\n    private final int s;\r\n\r\n    /**\r\n     * Computes a path between s and every other vertex in graph G\r\n     * @param G the graph\r\n     * @param s the source vertex\r\n     */\r\n     public DepthFirstPaths(Graph G, int s) {\r\n         this.s = s;\r\n         edgeTo = new int[G.V()];\r\n         marked = new boolean[G.V()];\r\n         dfs(G, s);\r\n     }\r\n\r\n     // Depth first search from v\r\n     private void dfs(Graph G, int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between the source s and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns a path between the source vertex s and vertex v, or\r\n      * null if no such path\r\n      * @param v the vertex\r\n      * @return the sequence of vertices on a path between the source vertex\r\n      *         s and vertex v, as an Iterable\r\n      */\r\n     public Iterable<Integer> pathTo(int v) {\r\n         // TODO\r\n     }\r\n}\r\n```\r\n\r\nLa classe `Graph` est déjà implémentée. En voici la spécification :\r\n\r\n``` java\r\npublic class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable<Integer> adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}\r\n```\r\n\r\n**Note:** Les questions suivantes vous demanderont d'implémenter tous\r\nles `TODO` de la classe `DepthFirstPaths`. Vous n'avez pas besoin de\r\nmettre les accolades (`{ }`) entourant le corps de la fonction dans\r\nvotre réponse.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6DepthFirstPaths/LSINF1121_PART6_DepthFirstPaths.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DepthFirstPaths",
            "archive_properties": {
                "folders": [
                    "Part6DepthFirstPaths"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Digraph (implem)",
            "description": "Implémentez l'interface `Digraph.java` dans la classe\r\n`DigraphImplem.java` à l'aide d'une structure de donnée de type\r\n`liste d'adjacence` pour représenter les graphes dirigés.\r\n\r\n``` java\r\npackage student;\r\n\r\npublic interface Digraph {\r\n\r\n    /**\r\n     * The number of vertices\r\n     */\r\n    public int V();\r\n\r\n    /**\r\n     * The number of edges\r\n     */\r\n    public int E();\r\n\r\n    /**\r\n     * Add the edge v->w\r\n     */\r\n    public void addEdge(int v, int w);\r\n\r\n    /**\r\n     * The nodes adjacent to edge v\r\n     */\r\n    public Iterable<Integer> adj(int v);\r\n\r\n    /**\r\n     * A copy of the digraph with all edges reversed\r\n     */\r\n    public Digraph reverse();\r\n\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6Digraph/LSINF1121_PART6_Digraph.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Digraph",
            "archive_properties": {
                "folders": [
                    "Part6Digraph"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Word Transformation Shortest Path (implem)",
            "description": "On vous demande d'implémenter la classe `WordTransformationSP` qui\r\npermet de trouver le plus court chemin permettant de passer d'un string\r\n*A* à un autre string *B* (avec la certitude qu'il y a bien un chemin\r\npermettant de transformer *A* en *B*).\r\n\r\nPour cela on definit une opération `rotation(x, y)` qui inverse l’ordre\r\ndes lettres entre la position x et y (non-inclus). Par exemple, avec\r\nA=`HAMBURGER`, si l'on fait `rotation(A, 4, 8)`, cela nous donne\r\n`HAMBEGRUR`. Vous pouvez donc constater que la sous-string `URGE` a été\r\ninversé en `EGRU` et le reste de la chaine est resté inchangé: `HAMB` +\r\n`ECRU` + `R` = `HAMBEGRUR`.\r\n\r\nDisons qu’une `rotation(x, y)` a un cout de y-x. Par exemple passer de\r\n`HAMBURGER` à `HAMBEGRUR` coût *8-4 = 4*.\r\n\r\nLa question est de savoir quel est le coût minimum pour atteindre une\r\nstring B à partir A?\r\n\r\nVous devez donc inmplémenter la méthode une fonction\r\n`public static int minimalCost(String A, String B)` qui retourne le cout\r\nminimal pour atteindre le String B depuis A en utilisant l'opération\r\nrotation.\r\n\r\n``` java\r\nimport java.util.*;\r\n\r\npublic  class WordTransformationSP {\r\n    /**\r\n     *\r\n     * Rotate the substring between start and end of a given string s\r\n     * eg. s = HAMBURGER, rotation(s,4,8) = HAMBEGRUR i.e. HAMB + EGRU + R\r\n     * @param s\r\n     * @param start\r\n     * @param end\r\n     * @return rotated string\r\n     */\r\n    public static String rotation(String s, int start, int end) {\r\n        return s.substring(0,start)+new StringBuilder(s.substring(start,end)).reverse().toString()+s.substring(end);\r\n    }\r\n\r\n    /**\r\n     * Compute the minimal cost from string \"from\" to string \"to\" representing the shortest path\r\n     * @param from\r\n     * @param to\r\n     * @return\r\n     */\r\n    public static int minimalCost(String from, String to) {\r\n        //TODO\r\n        return 0;\r\n    }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6DijkstraForWordTransformation/LSINF1121_PART6_WordTransformation.zip).\r\n\r\n**Note:** vous pouvez ajouter d'autres fonctions et des private classes\r\nsi vous le désirez.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6DijkstraForWordTransformation",
            "archive_properties": {
                "folders": [
                    "Part6DijkstraForWordTransformation"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Global Warming (implem)",
            "description": "Context\r\n=======\r\n\r\nSupposons la matrice 5x5 suivante:\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\n```\r\n\r\nreprésentée dans le tableau ci-dessous :\r\n\r\n<img src=\"Part6GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n\r\nChaque entrée de la matrice représente une altitude. L'objectif est\r\nd'implémenter une classe <span\r\nclass=\"title-ref\">GlobalWarmingImpl</span> qui implémente toutes les\r\nméthodes décrites dans <span class=\"title-ref\">GlobalWarming</span>\r\ndonnées ci-dessous.\r\n\r\nUn niveau d'eau global spécifié dans le constructeur modélise le fait\r\nque toutes les positions de la matrice avec une valeur &lt;= le niveau\r\nd'eau sont inondées (sous l'eau) et donc dangereuses. Dans l'exemple\r\nci-dessus, le niveau d'eau est de 3, tous les points sûrs sont en vert.\r\n\r\nLa méthode que vous devez implémenter doit permettre de calculer le\r\nchemin le plus court entre deux positions sont sur la même île\r\n\r\nnous supposons que les points sont **uniquement connectés verticalement\r\nou horizontalement**.\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6GlobalWarming/LSINF1121_PART6_GlobalWarming.zip).\r\n\r\n``` java\r\nimport java.util.List;\r\n\r\nabstract class GlobalWarming {\r\n\r\n    /**\r\n     * A class to represent the coordinates on the altitude matrix\r\n     */\r\n    public static class Point {\r\n\r\n        final int x, y;\r\n\r\n        Point(int x, int y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        @Override\r\n        public boolean equals(Object obj) {\r\n            Point p = (Point) obj;\r\n            return p.x == x && p.y == y;\r\n        }\r\n    }\r\n\r\n    final int[][] altitude;\r\n    final int waterLevel;\r\n\r\n\r\n    /**\r\n     * In the following, we assume that the points are connected to\r\n     * horizontal or vertical neighbors but not to the diagonal ones\r\n     * @param altitude is a n x n matrix of int values representing altitudes (positive or negative)\r\n     * @param waterLevel is the water level, every entry <= waterLevel is flooded\r\n     */\r\n    public GlobalWarming(int[][] altitude, int waterLevel) {\r\n        this.altitude = altitude;\r\n        this.waterLevel = waterLevel;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @param p1 a safe point with valid coordinates on altitude matrix\r\n     * @param p2 a safe point (different from p1) with valid coordinates on altitude matrix\r\n     * @return the shortest simple path (vertical/horizontal moves) if any between from p1 to p2 using only vertical/horizontal moves on safe points.\r\n     *         an empty list if not path exists (i.e. p1 and p2 are not on the same island).\r\n     */\r\n    public abstract List<Point> shortestPath(Point p1, Point p2);\r\n\r\n}\r\n```\r\n\r\nExercices Preliminaires\r\n=======================\r\n\r\n``` java\r\nint [][] tab = new int[][] {{1,3,3,1,3},\r\n                          {4,2,2,4,5},\r\n                          {4,4,1,4,2},\r\n                          {1,4,2,3,6},\r\n                          {1,1,1,6,3}};\r\nGlobalWarming gw = new MyGlobalWarming(tab,3);\r\n```\r\n\r\n<img src=\"Part6GlobalWarming/matrix.png\" class=\"align-center\" width=\"200\" alt=\"matrix example\" />\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6GlobalWarming",
            "archive_properties": {
                "folders": [
                    "Part6GlobalWarming"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "PART 6 : Maze (implem)",
            "description": "Nous sommes intéressés par la résolution de labyrinthe (labyrinthe)\r\nreprésenté par une matrice d'entiers 0-1 de taille <span\r\nclass=\"title-ref\">nxm</span>. Cette matrice est un tableau à deux\r\ndimensions. Une entrée égale à '1' signifie qu'il y a un mur et que\r\ncette position n'est donc pas accessible, tandis que '0' signifie que la\r\nposition est libre.\r\n\r\nNous vous demandons d'écrire un code Java pour découvrir le chemin le\r\nplus court entre deux coordonnées sur cette matrice de (x1, y1) à (x2,\r\ny2).\r\n\r\nLes déplacements ne peuvent être que verticaux ou horizontaux (pas en\r\ndiagonale), un pas à la fois.\r\n\r\nLe résultat du chemin est un `Iterable` de coordonnées de l'origine à la\r\ndestination. Ces coordonnées sont représentées par des entiers compris\r\nentre 0 et <span class=\"title-ref\">n \\* m-1</span>, où un entier 'a'\r\nreprésente la position <span class=\"title-ref\">x =a/m</span> et <span\r\nclass=\"title-ref\">y=a%m</span>.\r\n\r\nSi la position de début ou de fin est un mur ou s’il n’ya pas de chemin,\r\nil faut renvoyer un `Iterable` vide. Il en va de même s'il n'y a pas de\r\nchemin entre l'origine et la destination.\r\n\r\n``` java\r\nimport java.util.LinkedList;\r\n\r\npublic class Maze {\r\n    public static Iterable<Integer> shortestPath(int [][] maze,  int x1, int y1, int x2, int y2) {\r\n        //TODO\r\n        return new LinkedList<>();\r\n    }\r\n\r\n    public static int ind(int x,int y, int lg) {return x*lg + y;}\r\n\r\n    public static int row(int pos, int mCols) { return pos / mCols; }\r\n\r\n    public static int col(int pos, int mCols) { return pos % mCols; }\r\n}\r\n```\r\n\r\n[Le projet IntelliJ est disponible\r\nici](/course/LSINF1121-2016/Part6Maze/LSINF1121_PART6_Maze.zip).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "John Aoga",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part6Maze",
            "archive_properties": {
                "folders": [
                    "Part6Maze"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Règles de participation aux cours",
            "description": "Ce qui est interdit\r\n===================\r\n\r\nIl est interdit de partager son code avec un autre groupe et même avec\r\nson propre groupe pour les parties individuelles des missions.\r\n\r\nIl est interdit de publier son code de manière publique (`GitHub`,\r\n`Bitbucket`, `Dropbox` ou `Drive` partagé, etc) pendant et après le\r\nquadrimestre. Nous vous fournirons un repository `Git` pour vos travaux\r\nde groupes, qui sera seulement visible par les membres de votre groupe.\r\n\r\nIl est interdit de prendre le code de quelqu’un d’autre (même\r\npartiellement), y compris du code disponible sur le web. Seul le code\r\nfourni dans le livre de référence peut être utilisé.\r\n\r\nCe qui est autorisé\r\n===================\r\n\r\nÉchanger et discuter des idées avec des collègues (y compris d’un autre\r\ngroupe) est autorisé (oralement autour d’un tableau, sur un forum, etc).\r\nMais il est interdit de demander et/ou fournir une réponse toute faite\r\nou du code source.\r\n\r\nExemple de ce qui est interdit :\r\n\r\n-   Tu as mis quoi à la réponse à la question 1 ?\r\n\r\nExemple de ce qui est autorisé :\r\n\r\n-   J’hésite entre la méthode 1 et la méthode 2 pour réaliser l’objectif\r\n    1, je pense que la méthode 1 est meilleure pour la raison x, que\r\n    penses-tu de cet argument ?\r\n\r\nPourquoi ?\r\n==========\r\n\r\nCar le matériel pédagogique mis en place s’améliore chaque année et\r\nprend beaucoup de temps à développer. Le copyright de celui-ci\r\nappartient d’ailleurs à l’UCL et non aux étudiants.\r\n\r\nContourner les outils pédagogiques mis en place (par exemple en\r\nempruntant du code déjà écrit) ne vous rend pas service. C’est même le\r\nmeilleur moyen d’échouer à l’examen qui visera précisément à évaluer les\r\ncompétences acquises: programmation, réponses aux questions, etc.\r\n\r\nEn partageant du code ou des réponses (dans le meilleur des cas\r\napproximativement correctes...) vous inciteriez certains étudiants à ne\r\npas réfléchir par eux-mêmes, voir pire, à apprendre des réponses\r\npotentiellement erronées.\r\n\r\nLa note de participation ne vise pas l’exactitude des productions\r\n(réponses, codes) mais l’attitude et la motivation de l’étudiant à\r\ns’améliorer et acquérir les compétences visées.\r\n\r\nRisque\r\n======\r\n\r\nTout manquement à un de ces points sera sanctionné comme un acte de\r\ntricherie et sera dès lors reporté au président des jurys. Pour rappel,\r\nen cas de tricherie, l'étudiant peut se voir attribuer un zéro pour le\r\ncours, voire se voir attribuer zéro pour l'ensemble des cours de la\r\nsession.\r\n\r\nVos codes sont analysés par des outils de détection de plagiat. Un\r\nétudiant averti en vaut deux.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Kaczynski Frédéric",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/participation_rules",
            "archive_properties": {
                "folders": [
                    "participation_rules"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Rabin Karp",
            "description": "A la page 777 du livre \"Algorithms\" 4th edition, on vous propose\r\nl'implémentation suivante de l'algorithme de Rabin Karp.\r\n\r\n``` java\r\npublic class RabinKarp {\r\n  private String pat;      // the pattern  // needed only for Las Vegas\r\n  private long patHash;    // pattern hash value\r\n  private int m;           // pattern length\r\n  private long q;          // a large prime, small enough to avoid long overflow\r\n  private int R;           // radix\r\n  private long RM;         // R^(M-1) % Q\r\n\r\n  public RabinKarp(String pat) {\r\n      this.pat = pat;      // save pattern (needed only for Las Vegas)\r\n      R = 256;\r\n      m = pat.length();\r\n      q = longRandomPrime();\r\n\r\n      // precompute R^(m-1) % q for use in removing leading digit\r\n      RM = 1;\r\n      for (int i = 1; i <= m-1; i++)\r\n          RM = (R * RM) % q;\r\n      patHash = hash(pat, m);\r\n  }\r\n\r\n  // Compute hash for key[0..m-1].\r\n  private long hash(String key, int m) {\r\n      long h = 0;\r\n      for (int j = 0; j < m; j++)\r\n          h = (R * h + key.charAt(j)) % q;\r\n      return h;\r\n  }\r\n\r\n  // Monte Carlo\r\n  private boolean check(int i) {\r\n      return true;\r\n  }\r\n\r\n  // Returns the index of the first occurrrence of the pattern string in the text string.\r\n  public int search(String txt) {\r\n      int n = txt.length();\r\n      if (n < m) return n;\r\n      long txtHash = hash(txt, m);\r\n\r\n      // check for match at offset 0\r\n      if ((patHash == txtHash) && check(txt, 0))\r\n          return 0;\r\n\r\n      // check for hash match; if hash match, check for exact match\r\n      for (int i = m; i < n; i++) {\r\n          // Remove leading digit, add trailing digit, check for match.\r\n          txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;\r\n          txtHash = (txtHash*R + txt.charAt(i)) % q;\r\n\r\n          // match\r\n          int offset = i - m + 1;\r\n          if ((patHash == txtHash) && check(txt, offset))\r\n              return offset;\r\n      }\r\n\r\n      // no match\r\n      return n;\r\n  }\r\n\r\n\r\n  // a random 31-bit prime\r\n  private static long longRandomPrime() {\r\n      BigInteger prime = BigInteger.probablePrime(31, new Random());\r\n      return prime.longValue();\r\n  }\r\n\r\n}\r\n```\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 4"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexamen_rabinkarp",
            "archive_properties": {
                "folders": [
                    "preexamen_rabinkarp"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Breadth First Paths",
            "description": "Consider this class, `BreadthFirstShortestPaths`, that computes the\r\nshortest path between multiple node sources and any node in an\r\nundirected graph.\r\n\r\n``` java\r\n// TODO\r\n\r\npublic class BreadthFirstShortestPaths {\r\n\r\n    private static final int INFINITY = Integer.MAX_VALUE;\r\n    private boolean[] marked; // marked[v] = is there an s-v path\r\n    private int[] distTo;     // distTo[v] = number of edges shortest s-v path\r\n\r\n    /**\r\n     * Computes the shortest path between any\r\n     * one of the sources and very other vertex\r\n     * @param G the graph\r\n     * @param sources the source vertices\r\n     */\r\n     public BreadthFirstShortestPaths(Graph G, Iterable<Integer> sources) {\r\n         marked = new boolean[G.V()];\r\n         distTo = new int[G.V()];\r\n         for (int v = 0;v < G.V();v++) {\r\n             distTo[v] = INFINITY;\r\n         }\r\n         bfs(G, sources);\r\n     }\r\n\r\n     // Breadth-first search from multiple sources\r\n     private void bfs(Graph G, Iterable<Integer> sources) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between (at least one of) the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, and false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns the number of edges in a shortest path\r\n      * between one of the sources and vertex v?\r\n      * @param v the vertex\r\n      * @return the number of edges in a shortest path\r\n      */\r\n     public int distTo(int v) {\r\n         // TODO\r\n     }\r\n}\r\n```\r\n\r\nThe class `Graph` is already implemented. Here is its specification:\r\n\r\n``` java\r\npublic class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable<Integer> adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}\r\n```\r\n\r\n**Note:** The following questions will ask you to implement the function\r\nleft out. You don't need to put the brackets (`{ }`) surrounding the\r\nfunction body in your answer.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_bfs",
            "archive_properties": {
                "folders": [
                    "preexam_bfs"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Bloom Filters",
            "description": "Les filtres de Bloom\r\n====================\r\n\r\nUn filtre de Bloom, est une structure de donnée très compacte et\r\nefficace qui permet d'implémenter un test d'appartenance rapide\r\n(`.contains()`) à un très grand *ensemble*. Cependant, contrairement au\r\ntest d'appartenance à un ensemble tel qu'implémenté à l'aide d'une\r\nHashMap, le test d'appartenance implémenté via un filtre de bloom peut\r\nrenvoyer un résultat erroné (faux positifs possibles mais pas de faux\r\nnégatifs) dans certains cas et cela, avec une faible probabilité.\r\n\r\nL'efficacité de cette structure, et le fait qu'elle ne requière qu'une\r\nquantité très faible (et constante !) de mémoire quel que soit le nombre\r\nd'éléments contenus dans l'ensemble en ont fait une structure de choix\r\npour un très grand nombre d'applications. A titre d'exemple, on\r\nmentionnera le fait que les filtres de Bloom sont utilisés par certains\r\ndevices réseaux pour faire du *Deep Packet Inspection*, ou encore que\r\nles bases de données *Google Big Table*, *Apache Cassandra* ou encore\r\n*Postgresql* utilisent cette structure de donnée afin de tester si une\r\ndonnée se trouve en cache ou non.\r\n\r\nEn effet la recherche de la donnée étant généralement coûteuse, un\r\nfiltre de Bloom est utilisé pour éviter de faire une recherche si la\r\ndonnée n'est pas présente. Par contre, comme les erreurs de type\r\nfaux-positifs sont possibles, le filtre de Bloom peut dire que la donnée\r\ns'y trouve alors que ça n'est pas vrai. Dans ce cas, il faudra effectuer\r\nla recherche pour vérifier et payer le coût de cette recherche (par\r\nexemple une recherche linéaire avec des accès sur le disque).\r\n\r\nConcrètement\r\n============\r\n\r\nConcrètement, un filtre de bloom consiste en un vecteur\r\n*V* = *v*<sub>1</sub>..*v*<sub>*n*</sub> de bit et d'un ensemble\r\n*F* = *f*<sub>1</sub>..*f*<sub>*k*</sub> de fonctions de hachage\r\n\r\nPour ajouter un élément *X* dans le set, on applique successivement\r\nchacune des fonctions *f*<sub>*i*</sub> ∈ *F* de hachage. L'application\r\nde chacune de ces fonctions à l'élément *X* renvoie un nombre\r\n*h*<sub>*i*</sub> ∈ \\[0..*n*−1\\]. Pour marquer l'ajout de *X* au filtre\r\nde bloom, on met à 1 simplement chacun des\r\n*v*<sub>*h*<sub>*i*</sub></sub> bits dans *V*.\r\n\r\nDe façon similaire, pour tester l'appartenance d'un élément *X* au set,\r\non vérifie que le *h*<sub>*i*</sub> ème bit  ∈ *V* correspondant à\r\n*f*<sub>*i*</sub>(*X*) est égal à 1. Le test d'appartenance ne renverra\r\n<span class=\"title-ref\">true</span> que ssi, cette condition est\r\nvérifiée pour chacune des *f*<sub>*i*</sub> ∈ *F*.\r\n\r\nExemples\r\n--------\r\n\r\nEn supposant qu'on ait un filtre de Bloom représenté par 1 byte et 3\r\nfonctions de hachage telles que:\r\n\r\n``` \r\nf1(\"Salut\") = 0\r\nf2(\"Salut\") = 1\r\nf3(\"Salut\") = 2\r\n\r\net\r\n\r\nf1(\"1121\") = 0\r\nf2(\"1121\") = 1\r\nf3(\"1121\") = 4\r\n```\r\n\r\nL'ajout de \"Salut\" au filtre 00000000 transforme celui-ci en 11100000.\r\nSi par la suite on veut tester que \"Salut\" est bien présent dans le\r\nfiltre, on s'assure que les bits v1, v2 et v3 sont bien égaux à 1.\r\n\r\nEn continuant sur le même exemple, on voit que la chaine \"1121\" n'est\r\npas présente dans la structure puisque le 4eme bit est égal à 0.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Xavier Gillard",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "text": "Pierre Schaus",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "exam"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_bloomfilter",
            "archive_properties": {
                "folders": [
                    "preexam_bloomfilter"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Depth First Paths",
            "description": "Consider this class, `DepthFirstPaths`, that computes paths to any\r\nconnected node from a source node `s` in an undirected graph.\r\n\r\n``` java\r\n// TODO\r\n\r\npublic class DepthFirstPaths {\r\n    private boolean[] marked; // marked[v] = is there an s-v path?\r\n    private int[] edgeTo;     // edgeTo[v] = last edge on s-v path\r\n    private final int s;\r\n\r\n    /**\r\n     * Computes a path between s and every other vertex in graph G\r\n     * @param G the graph\r\n     * @param s the source vertex\r\n     */\r\n     public DepthFirstPaths(Graph G, int s) {\r\n         this.s = s;\r\n         edgeTo = new int[G.V()];\r\n         marked = new boolean[G.V()];\r\n         dfs(G, s);\r\n     }\r\n\r\n     // Depth first search from v\r\n     private void dfs(Graph G, int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Is there a path between the source s and vertex v?\r\n      * @param v the vertex\r\n      * @return true if there is a path, false otherwise\r\n      */\r\n     public boolean hasPathTo(int v) {\r\n         // TODO\r\n     }\r\n\r\n     /**\r\n      * Returns a path between the source vertex s and vertex v, or\r\n      * null if no such path\r\n      * @param v the vertex\r\n      * @return the sequence of vertices on a path between the source vertex\r\n      *         s and vertex v, as an Iterable\r\n      */\r\n     public Iterable<Integer> pathTo(int v) {\r\n         // TODO\r\n     }\r\n}\r\n```\r\n\r\nThe class `Graph` is already implemented. Here is its specification:\r\n\r\n``` java\r\npublic class Graph {\r\n    // @return the number of vertices\r\n    public int V() { }\r\n\r\n    // @return the number of edges\r\n    public int E() { }\r\n\r\n    // Add edge v-w to this graph\r\n    public void addEdge(int v, int w) { }\r\n\r\n    // @return the vertices adjacent to v\r\n    public Iterable<Integer> adj(int v) { }\r\n\r\n    // @return a string representation\r\n    public String toString() { }\r\n}\r\n```\r\n\r\n**Note:** The following questions will ask you to implement the function\r\nleft out. You don't need to put the brackets (`{ }`) surrounding the\r\nfunction body in your answer.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 6"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_dfs",
            "archive_properties": {
                "folders": [
                    "preexam_dfs"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Heap",
            "description": "Consider the `Heap` data structure in which we progressively add\r\nnumbers.\r\n\r\nThe following questions will ask you to write a representation of the\r\n`Heap` as we add objects in it. You must write the `Heap` as if it was\r\nstored in an array. For example, if your answer is:\r\n\r\n    9\r\n    / \\\r\n    5   8\r\n    / \\\r\n    4   3\r\n\r\nYou would write:\r\n\r\n    9 5 8 4 3\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_heap",
            "archive_properties": {
                "folders": [
                    "preexam_heap"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Merge Sort",
            "description": "Consider the (top-down) sorting algorithm `Merge Sort`\r\n\r\n``` java\r\npublic class MergeSort {\r\n    /**\r\n     * Pre-conditions: a[lo..mid] and a[mid+1..hi] are sorted\r\n     * Post-conditions: a[lo..hi] is sorted\r\n     */\r\n    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) {\r\n        for (int k = lo; k <= hi; k++) {\r\n            aux[k] = a[k];\r\n        }\r\n\r\n        int i = lo;\r\n        int j = mid + 1;\r\n        for (int k = lo; k <= hi; k++) {\r\n            if (i > mid) {\r\n                a[k] = aux[j++];\r\n            } else if (j > hi) {\r\n                a[k] = aux[i++];\r\n            } else if (aux[j].compareTo(aux[i]) < 0) {\r\n                a[k] = aux[j++];\r\n            } else {\r\n                a[k] = aux[i++];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Mergesort a[lo..hi] using auxiliary array aux[lo..hi]\r\n    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Rearranges the array in ascending order, using the natural order\r\n     */\r\n    public static void sort(Comparable[] a) {\r\n        // TODO\r\n    }\r\n}\r\n```\r\n\r\n**Note:** The following questions will ask you to implement the function\r\nleft out. You don't need to put the brackets (`{ }`) surrounding the\r\nfunction body in your answer.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 2"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_merge_sort",
            "archive_properties": {
                "folders": [
                    "preexam_merge_sort"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Red Black Tree",
            "description": "Consider an empty `Red-Black Tree` in which we progressively add\r\nnumbers.\r\n\r\nThe following questions will ask you to write a representation of the\r\n`Red-Black Tree` as we add objects in it. Write it as if you were\r\nreading from left to right and from top to bottom (ignoring the possible\r\nblanks). For example, if your answer is:\r\n\r\n    6\r\n    /   \\\r\n    (2 4)   7\r\n    / | \\    \\\r\n    1  3  5    9\r\n\r\nYou would write:\r\n\r\n    6 24 7 1 3 5 9\r\n\r\nNotice how the 2-3 node composed of `2` and `4` is written in a merged\r\nway (`24`).\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_redblacktree",
            "archive_properties": {
                "folders": [
                    "preexam_redblacktree"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "QCM Binary Trees",
            "description": "Consider this ordered binary tree:\r\n\r\n    4\r\n    /   \\\r\n    2       5\r\n    / \\     / \\\r\n    1   3   6   7\r\n\r\nWe traverse this tree and we print the value of each node we visit it.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_tree_qcm",
            "archive_properties": {
                "folders": [
                    "preexam_tree_qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Union find",
            "description": "Consider a graph made of 10 disjoint nodes (numbered from 0 to 9). We\r\nuse a union-find data structure to represent this graph. At first, each\r\nnode is contained in a partition named after the node. Thus, the\r\nrepresentation of the graph in the array `id[]` is:\r\n\r\n    0 1 2 3 4 5 6 7 8 9\r\n\r\nThe following questions will ask you to type the representation of the\r\ngraph after we use the **quick-find** algorithm to add an edge between 2\r\nnodes. You must type this representation in the same way it was typed\r\nabove.\r\n\r\n**Note:** When we join `p-q` with the quick-find algorithm, the\r\nconvention is to change `id[p]` (and potentially other entries) but not\r\n`id[q]`.\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Frédéric Kaczynski",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "match"
                },
                {
                    "category": 2,
                    "text": "Mission 5"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/preexam_unionfind",
            "archive_properties": {
                "folders": [
                    "preexam_unionfind"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Binary Search Tree",
            "description": "Etant donné un arbre de recherche binaire, dont les noeuds implémentent\r\nl'interface Node:\r\n\r\n``` java\r\ninterface Node {\r\n    /**\r\n      * @return la valeur contenue dans ce noeud\r\n      */\r\n    int getValue();\r\n\r\n    /**\r\n     * @return Le noeud situe a gauche (dont la valeur est < que la valeur actuelle) s'il existe, null sinon\r\n     */\r\n    Node getLeft();\r\n\r\n    /**\r\n      * @return Le noeud situe a droite (dont la valeur est > que la valeur actuelle) s'il existe, null sinon\r\n      */\r\n    Node getRight();\r\n}\r\n```\r\n\r\nL'on vous demande de fournir le **corps** de la fonction *ceil*, qui\r\ntrouve dans l'arbre le plus petit élément plus grand ou égal à <span\r\nclass=\"title-ref\">value</span> (donc soit l'élément lui-même soit\r\nl'élément situé directement après par ordre de grandeur). Si un tel\r\nélément n'existe pas, elle doit retourner <span\r\nclass=\"title-ref\">null</span>.\r\n\r\n[Un projet Eclipse contenant des tests basiques vous est fourni en\r\ncliquant sur ce\r\nlien.](https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016bst/project.zip)\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Guillaume Derval",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "code"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_PROGRAMMING-LANGUAGE_",
                    "text": "java"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016bst",
            "archive_properties": {
                "folders": [
                    "whiteexam2016bst"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        },
        {
            "title": "Questions à choix multiples",
            "description": "\r\n",
            "tags": [
                {
                    "text": "INGINIOUS",
                    "autoGenerated": true,
                    "category_id": "_PLATFORM_"
                },
                {
                    "text": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms",
                    "autoGenerated": true,
                    "category_id": "_SOURCE_"
                },
                {
                    "text": "[LSINF1121] Algorithmique et structures de données",
                    "autoGenerated": true,
                    "category_id": "_COURSE_"
                },
                {
                    "text": "Antoine Cailliau",
                    "autoGenerated": true,
                    "category_id": "_AUTHOR_"
                },
                {
                    "autoGenerated": true,
                    "category_id": "_EXERCISE-TYPE_",
                    "text": "multiple_choice"
                },
                {
                    "category": 2,
                    "text": "Mission 3"
                }
            ],
            "url": "https://inginious.info.ucl.ac.be/course/LSINF1121-2016/whiteexam2016qcm",
            "archive_properties": {
                "folders": [
                    "whiteexam2016qcm"
                ],
                "files": [
                    "course.yaml"
                ]
            }
        }
    ],
    "own_categories": {
        "0": "thématique",
        "1": "Misconception",
        "2": "autres"
    },
    "extraction_date": "2019-12-14T12:01:53.077Z",
    "url": "https://github.com/UCL-INGI/LSINF1121-Data-Structures-And-Algorithms"
}